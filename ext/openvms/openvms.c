/*
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
   | Copyright (c) 1997-2008 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
   +----------------------------------------------------------------------+
*/
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#define TSRMLS_CC

#include "php.h"
#include "ext/standard/info.h"
#include "php_openvms.h"

#ifndef __NEW_STARLET
#define __NEW_STARLET
#define __NEW_STARLET_SET
#endif
#include <lib$routines.h>
#include <statedef.h>
#include <ppropdef.h>
#include <descrip.h>
#include <starlet.h>
#include <iosbdef.h>
#include <jpidef.h>
#include <uicdef.h>
#include <syidef.h>
#include <dvidef.h>
#include <prvdef.h>
#include <efndef.h>
#include <iledef.h>
#include <ssdef.h>
#include <lnmdef.h>
#include <psldef.h>
#include <libdef.h>
#include <libclidef.h>
#include "ilemac.h"
#include "cvtfnm.h"
#ifdef  __NEW_STARLET_SET
#undef  __NEW_STARLET_SET
#undef  __NEW_STARLET
#endif

#define BOOL	1	/* Bool value	*/
#define BYTE	2	/* Byte value	*/
#define LONG	3	/* Long value	*/
#define TEXT	4	/* Text string	*/
#define DATE	5	/* Date string	*/
#define PRIV	6	/* Priv string	*/
#define RLST	7	/* Rights list 	*/
#define SOGW	8	/* SOGW Prots   */
#define UIC     9	/* Uic value	*/

#ifndef DATE_TIME_LEN
#define DATE_TIME_LEN 23
#endif
#ifndef IDENT_BUF_LEN
#define IDENT_BUF_LEN 32
#endif
#ifndef PRIV_BUF_LEN
#define PRIV_BUF_LEN 512
#endif
#ifndef PROT_BUF_LEN
#define PROT_BUF_LEN 256
#endif
#ifndef UIC_BUF_LEN
#define UIC_BUF_LEN 64
#endif
#ifndef MSG_BUF_LEN
#define MSG_BUF_LEN 256
#endif

#ifndef OPENVMS_CVT_VMS_TO_UNIX
#define OPENVMS_CVT_VMS_TO_UNIX 1
#endif
#ifndef OPENVMS_CVT_UNIX_TO_VMS
#define OPENVMS_CVT_UNIX_TO_VMS 2
#endif

#if defined(__VMS) && __INITIAL_POINTER_SIZE == 64
#   define  set_dsc_string(dsc, val)    \
        (dsc).dsc$a_pointer = alloca(strlen(val)+1);    \
        strcpy((dsc).dsc$a_pointer, val);
#else
#   define  set_dsc_string(dsc, val)    (dsc).dsc$a_pointer = (__char_ptr32)(val)
#endif

#define APPEND(str,itm,sep)		\
    if (strlen (str) == 0)		\
        strcat (str, itm);              \
    else                                \
        {                               \
        strcat (str, sep);              \
        strcat (str, itm);              \
        }

struct item_code {
   char *item_name;
   int   item_code;
   int   item_type;
   int   item_size;
};

/*
** DVIDEF.H note
**
**   There is a difference in item codes from V7.2 of VMS
**   to V7.3 of VMS.  This accounts for the conditional compiles
**   shown below.
**
**   In V7.2 (and subsequent (V7.2-2)) DVI$_DRIVER_CLASS is defined
**   as 336.  DVI$_DRIVER_IMAGE_NAME and DVI$_CLIENT_DEVICE are
**   not defined.
**
**   In V7.3 (and subsequent (V7.3-2)) DVI$_DRIVER_CLASS is not
**   defined.  DVI$_DRIVER_IMAGE_NAME is 336 and DVI$_CLIENT_DEVICE
**   is defined as 338.
**
**   This has the added effect of moving the symbols that follow
**   in the #define table.  DVI$_FC_PORT_NAME, DVI$_FC_NODE_NAME,
**   and DVI$_WWID all get changed.
**
**   This means that modules compiled against V7.2-2 are not
**   compatible with V7.3 and above.  Those compiled against V7.3
**   are not compatible with V7.2-2.
*/

struct item_code lnm_items[] = {
    // INDEX goes first!
    {"INDEX", LNM$_INDEX, LONG, 4 },
    // ATTRIBUTES goes second (before STRING)!
    {"ATTRIBUTES", LNM$_ATTRIBUTES, LONG, 4 },
    {"STRING", LNM$_STRING, TEXT, 255 },
    {"ACMODE", LNM$_ACMODE, BYTE, 1 },
    {"ACCESS_MODE", LNM$_ACMODE, BYTE, 1 },
    {"LENGTH", LNM$_LENGTH, LONG, 4 },
    {"MAX_INDEX", LNM$_MAX_INDEX, LONG, 4 },
    {"PARENT", LNM$_PARENT, TEXT, 31 },
    {"TABLE_NAME", LNM$_TABLE, TEXT, 31 },
};

// sorted by second field
struct item_code lnm_item_attr[] = {
    { "NO_ALIAS", LNM$M_NO_ALIAS, BYTE, 1 },
    { "CONFINE", LNM$M_CONFINE, BYTE, 1 },
    { "CRELOG", LNM$M_CRELOG, BYTE, 1 },
    { "TABLE", LNM$M_TABLE, BYTE, 1 },
    { "CONCEALED", LNM$M_CONCEALED, BYTE, 1 },
    { "TERMINAL", LNM$M_TERMINAL, BYTE, 1 },
    { "EXISTS", LNM$M_EXISTS, BYTE, 1 },
    { "SHAREABLE", LNM$M_SHAREABLE, BYTE, 1 },
    { "CLUSTERWIDE", LNM$M_CLUSTERWIDE, BYTE, 1 },
    { "DCL_REQUEST", LNM$M_DCL_REQUEST, BYTE, 1 },
    { "CREATE_IF", LNM$M_CREATE_IF, BYTE, 1 },
    { "CASE_BLIND", LNM$M_CASE_BLIND, BYTE, 1 },
    { "INTERLOCKED", LNM$M_INTERLOCKED, BYTE, 1 },
    { "LOCAL_ACTION", LNM$M_LOCAL_ACTION, BYTE, 1 },
};

struct item_code dvi_items[] = {
 {"ACPPID", DVI$_ACPPID, BYTE, 4},
 {"ACPTYPE", DVI$_ACPTYPE, LONG, 4},
 {"ALL", DVI$_ALL, BOOL, 4},
 {"ALLDEVNAM", DVI$_ALLDEVNAM, TEXT, 64},
 {"ALLOCLASS", DVI$_ALLOCLASS, LONG, 4},
 {"ALT_HOST_AVAIL", DVI$_ALT_HOST_AVAIL, BOOL, 4},
 {"ALT_HOST_NAME", DVI$_ALT_HOST_NAME, TEXT, 64},
 {"ALT_HOST_TYPE", DVI$_ALT_HOST_TYPE, TEXT, 4},
 {"AVL", DVI$_AVL, BOOL, 4},
 {"CCL", DVI$_CCL, BOOL, 4},
#ifdef DVI$_CLIENT_DEVICE
 {"CLIENT_DEVICE", DVI$_CLIENT_DEVICE, BOOL, 4},
#endif
 {"CLUSTER", DVI$_CLUSTER, LONG, 4},
 {"CONCEALED", DVI$_CONCEALED, BOOL, 4},
 {"CYLINDERS", DVI$_CYLINDERS, LONG, 4},
 {"DAPDEVNAM", DVI$_DAPDEVNAM, TEXT, 64},
 {"DEVBUFSIZ", DVI$_DEVBUFSIZ, LONG, 4},
 {"DEVCHAR", DVI$_DEVCHAR, LONG, 4},
 {"DEVCHAR2", DVI$_DEVCHAR2, LONG, 4},
 {"DEVCLASS", DVI$_DEVCLASS, LONG, 4},
 {"DEVDEPEND", DVI$_DEVDEPEND, LONG, 4},
 {"DEVDEPEND2", DVI$_DEVDEPEND2, LONG, 4},
 {"DEVDEPEND3", DVI$_DEVDEPEND3, LONG, 4},
 {"DEVDEPEND4", DVI$_DEVDEPEND4, LONG, 4},
 {"DEVICE_TYPE_NAME", DVI$_DEVICE_TYPE_NAME, TEXT, 64},
 {"DEVLOCKNAM", DVI$_DEVLOCKNAM, TEXT, 64},
 {"DEVNAM", DVI$_DEVNAM, TEXT, 64},
 {"DEVSTS", DVI$_DEVSTS, LONG, 4},
 {"DEVTYPE", DVI$_DEVTYPE, LONG, 4},
 {"DFS_ACCESS", DVI$_DFS_ACCESS, BOOL, 4},
 {"DIR", DVI$_DIR, BOOL, 4},
 {"DISPLAY_DEVNAM", DVI$_DISPLAY_DEVNAM, TEXT, 256},
 {"DMT", DVI$_DMT, BOOL, 4},
#ifdef DVI$_DRIVER_CLASS
 {"DRIVER_CLASS", DVI$_DRIVER_CLASS, TEXT, 64},
#endif
#ifdef DVI$_DRIVER_IMAGE_NAME
 {"DRIVER_IMAGE_NAME", DVI$_DRIVER_IMAGE_NAME, TEXT, 64},
#endif
 {"DUA", DVI$_DUA, BOOL, 4},
 {"ELG", DVI$_ELG, BOOL, 4},
 {"ERRCNT", DVI$_ERRCNT, LONG, 4},
 {"FC_NODE_NAME", DVI$_FC_NODE_NAME, TEXT, 32},
 {"FC_PORT_NAME", DVI$_FC_PORT_NAME, TEXT, 32},
 {"FOD", DVI$_FOD, BOOL, 4},
 {"FOR", DVI$_FOR, BOOL, 4},
 {"FREEBLOCKS", DVI$_FREEBLOCKS, LONG, 4},
 {"FULLDEVNAM", DVI$_FULLDEVNAM, TEXT, 64},
 {"GEN", DVI$_GEN, BOOL, 4},
 {"HOST_AVAIL", DVI$_HOST_AVAIL, BOOL, 4},
 {"HOST_COUNT", DVI$_HOST_COUNT, LONG, 4},
 {"HOST_NAME", DVI$_HOST_NAME, TEXT, 64},
 {"HOST_TYPE", DVI$_HOST_TYPE, TEXT, 4},
 {"IDV", DVI$_IDV, BOOL, 4},
 {"LOCKID", DVI$_LOCKID, BYTE, 4},
 {"LOGVOLNAM", DVI$_LOGVOLNAM, TEXT, 64},
 {"MAXBLOCK", DVI$_MAXBLOCK, LONG, 4},
 {"MAXFILES", DVI$_MAXFILES, LONG, 4},
 {"MBX", DVI$_MBX, BOOL, 4},
 {"MEDIA_ID", DVI$_MEDIA_ID, LONG, 4},
 {"MEDIA_NAME", DVI$_MEDIA_NAME, TEXT, 64},
 {"MEDIA_TYPE", DVI$_MEDIA_TYPE, TEXT, 64},
 {"MNT", DVI$_MNT, BOOL, 4},
 {"MOUNTCNT", DVI$_MOUNTCNT, LONG, 4},
 {"MSCP_UNIT_NUMBER", DVI$_MSCP_UNIT_NUMBER, LONG, 4},
 {"MT3_DENSITY", DVI$_MT3_DENSITY, LONG, 4},
 {"MT3_SUPPORTED", DVI$_MT3_SUPPORTED, BOOL, 4},
 {"NET", DVI$_NET, BOOL, 4},
 {"NEXTDEVNAM", DVI$_NEXTDEVNAM, TEXT, 64},
 {"ODV", DVI$_ODV, BOOL, 4},
 {"OPCNT", DVI$_OPCNT, LONG, 4},
 {"OPR", DVI$_OPR, BOOL, 4},
 {"OWNUIC", DVI$_OWNUIC, UIC, 4},
 {"PID", DVI$_PID, BYTE, 4},
 {"PREFERRED_CPU", DVI$_PREFERRED_CPU, LONG, 4},
 {"RCK", DVI$_RCK, BOOL, 4},
 {"RCT", DVI$_RCT, BOOL, 4},
 {"REC", DVI$_REC, BOOL, 4},
 {"RECSIZ", DVI$_RECSIZ, LONG, 4},
 {"REFCNT", DVI$_REFCNT, LONG, 4},
 {"REMOTE_DEVICE", DVI$_REMOTE_DEVICE, BOOL, 4},
 {"RND", DVI$_RND, BOOL, 4},
 {"ROOTDEVNAM", DVI$_ROOTDEVNAM, TEXT, 64},
 {"RTM", DVI$_RTM, BOOL, 4},
 {"SDI", DVI$_SDI, BOOL, 4},
 {"SECTORS", DVI$_SECTORS, LONG, 4},
 {"SERIALNUM", DVI$_SERIALNUM, LONG, 4},
 {"SERVED_DEVICE", DVI$_SERVED_DEVICE, BOOL, 4},
 {"SET_HOST_TERMINAL", DVI$_SET_HOST_TERMINAL, BOOL, 4},
 {"SHDW_CATCHUP_COPYING", DVI$_SHDW_CATCHUP_COPYING, BOOL, 4},
 {"SHDW_FAILED_MEMBER", DVI$_SHDW_FAILED_MEMBER, BOOL, 4},
 {"SHDW_MASTER", DVI$_SHDW_MASTER, BOOL, 4},
 {"SHDW_MASTER_NAME", DVI$_SHDW_MASTER_NAME, TEXT, 64},
 {"SHDW_MEMBER", DVI$_SHDW_MEMBER, BOOL, 4},
 {"SHDW_MERGE_COPYING", DVI$_SHDW_MERGE_COPYING, BOOL, 4},
 {"SHDW_NEXT_MBR_NAME", DVI$_SHDW_NEXT_MBR_NAME, TEXT, 64},
 {"SHR", DVI$_SHR, BOOL, 4},
 {"SPL", DVI$_SPL, BOOL, 4},
 {"SQD", DVI$_SQD, BOOL, 4},
 {"STS", DVI$_STS, LONG, 4},
 {"SWL", DVI$_SWL, BOOL, 4},
 {"TRACKS", DVI$_TRACKS, LONG, 4},
 {"TRANSCNT", DVI$_TRANSCNT, LONG, 4},
 {"TRM", DVI$_TRM, BOOL, 4},
 {"TT_ACCPORNAM", DVI$_TT_ACCPORNAM, TEXT, 64},
 {"TT_ALTYPEAHD", DVI$_TT_ALTYPEAHD, BOOL, 4},
 {"TT_ANSICRT", DVI$_TT_ANSICRT, BOOL, 4},
 {"TT_ANSI_COLOR", DVI$_TT_ANSI_COLOR, BOOL, 4},
 {"TT_APP_KEYPAD", DVI$_TT_APP_KEYPAD, BOOL, 4},
 {"TT_ASIAN_MODE", DVI$_TT_ASIAN_MODE, LONG, 4},
 {"TT_AUTOBAUD", DVI$_TT_AUTOBAUD, BOOL, 4},
 {"TT_AVO", DVI$_TT_AVO, BOOL, 4},
 {"TT_BLOCK", DVI$_TT_BLOCK, BOOL, 4},
 {"TT_BRDCSTMBX", DVI$_TT_BRDCSTMBX, BOOL, 4},
 {"TT_CHARSET", DVI$_TT_CHARSET, LONG, 4},
 {"TT_CRFILL", DVI$_TT_CRFILL, BOOL, 4},
 {"TT_CS_HANGUL", DVI$_TT_CS_HANGUL, BOOL, 4},
 {"TT_CS_HANYU", DVI$_TT_CS_HANYU, BOOL, 4},
 {"TT_CS_HANZI", DVI$_TT_CS_HANZI, BOOL, 4},
 {"TT_CS_KANA", DVI$_TT_CS_KANA, BOOL, 4},
 {"TT_CS_KANJI", DVI$_TT_CS_KANJI, BOOL, 4},
 {"TT_CS_THAI", DVI$_TT_CS_THAI, BOOL, 4},
 {"TT_DCL_MAILBX", DVI$_TT_DCL_MAILBX, BOOL, 4},
 {"TT_DECCRT", DVI$_TT_DECCRT, BOOL, 4},
 {"TT_DECCRT2", DVI$_TT_DECCRT2, BOOL, 4},
 {"TT_DECCRT3", DVI$_TT_DECCRT3, BOOL, 4},
 {"TT_DECCRT4", DVI$_TT_DECCRT4, BOOL, 4},
 {"TT_DECCRT5", DVI$_TT_DECCRT5, BOOL, 4},
 {"TT_DIALUP", DVI$_TT_DIALUP, BOOL, 4},
 {"TT_DISCONNECT", DVI$_TT_DISCONNECT, BOOL, 4},
 {"TT_DMA", DVI$_TT_DMA, BOOL, 4},
 {"TT_DRCS", DVI$_TT_DRCS, BOOL, 4},
 {"TT_EDIT", DVI$_TT_EDIT, BOOL, 4},
 {"TT_EDITING", DVI$_TT_EDITING, BOOL, 4},
 {"TT_EIGHTBIT", DVI$_TT_EIGHTBIT, BOOL, 4},
 {"TT_ESCAPE", DVI$_TT_ESCAPE, BOOL, 4},
 {"TT_FALLBACK", DVI$_TT_FALLBACK, BOOL, 4},
 {"TT_HALFDUP", DVI$_TT_HALFDUP, BOOL, 4},
 {"TT_HANGUP", DVI$_TT_HANGUP, BOOL, 4},
 {"TT_HOSTSYNC", DVI$_TT_HOSTSYNC, BOOL, 4},
 {"TT_INSERT", DVI$_TT_INSERT, BOOL, 4},
 {"TT_LFFILL", DVI$_TT_LFFILL, BOOL, 4},
 {"TT_LOCALECHO", DVI$_TT_LOCALECHO, BOOL, 4},
 {"TT_LOWER", DVI$_TT_LOWER, BOOL, 4},
 {"TT_MBXDSABL", DVI$_TT_MBXDSABL, BOOL, 4},
 {"TT_MECHFORM", DVI$_TT_MECHFORM, BOOL, 4},
 {"TT_MECHTAB", DVI$_TT_MECHTAB, BOOL, 4},
 {"TT_MODEM", DVI$_TT_MODEM, BOOL, 4},
 {"TT_MODHANGUP", DVI$_TT_MODHANGUP, BOOL, 4},
 {"TT_MULTISESSION", DVI$_TT_MULTISESSION, BOOL, 4},
 {"TT_NOBRDCST", DVI$_TT_NOBRDCST, BOOL, 4},
 {"TT_NOECHO", DVI$_TT_NOECHO, BOOL, 4},
 {"TT_NOTYPEAHD", DVI$_TT_NOTYPEAHD, BOOL, 4},
 {"TT_OPER", DVI$_TT_OPER, BOOL, 4},
 {"TT_PAGE", DVI$_TT_PAGE, LONG, 4},
 {"TT_PASSALL", DVI$_TT_PASSALL, BOOL, 4},
 {"TT_PASTHRU", DVI$_TT_PASTHRU, BOOL, 4},
 {"TT_PHYDEVNAM", DVI$_TT_PHYDEVNAM, TEXT, 64},
 {"TT_PRINTER", DVI$_TT_PRINTER, BOOL, 4},
 {"TT_READSYNC", DVI$_TT_READSYNC, BOOL, 4},
 {"TT_REGIS", DVI$_TT_REGIS, BOOL, 4},
 {"TT_REMOTE", DVI$_TT_REMOTE, BOOL, 4},
 {"TT_SCOPE", DVI$_TT_SCOPE, BOOL, 4},
 {"TT_SCRIPT", DVI$_TT_SCRIPT, BOOL, 4},
 {"TT_SECURE", DVI$_TT_SECURE, BOOL, 4},
 {"TT_SETSPEED", DVI$_TT_SETSPEED, BOOL, 4},
 {"TT_SIXEL", DVI$_TT_SIXEL, BOOL, 4},
 {"TT_SYSPWD", DVI$_TT_SYSPWD, BOOL, 4},
 {"TT_TTSYNC", DVI$_TT_TTSYNC, BOOL, 4},
 {"TT_WRAP", DVI$_TT_WRAP, BOOL, 4},
 {"UNIT", DVI$_UNIT, LONG, 4},
 {"VOLCOUNT", DVI$_VOLCOUNT, LONG, 4},
 {"VOLNAM", DVI$_VOLNAM, TEXT, 12},
 {"VOLNUMBER", DVI$_VOLNUMBER, LONG, 4},
 {"VOLSETMEM", DVI$_VOLSETMEM, BOOL, 4},
 {"VPROT", DVI$_VPROT, SOGW, 4},
 {"WCK", DVI$_WCK, BOOL, 4},
 {"WWID", DVI$_WWID, TEXT, 380},
 {"", 0, 0, 0}};

struct item_code dvi_acptypes[] = {
 {"F11V1", DVI$C_ACP_F11V1, 0, 0},
 {"F11V2", DVI$C_ACP_F11V2, 0, 0},
 {"MTA", DVI$C_ACP_MTA, 0, 0},
 {"NET", DVI$C_ACP_NET, 0, 0},
 {"REM", DVI$C_ACP_REM, 0, 0},
 {"HBS", DVI$C_ACP_HBS, 0, 0},
 {"F11V3", DVI$C_ACP_F11V3, 0, 0},
 {"F11V4", DVI$C_ACP_F11V4, 0, 0},
 {"F64", DVI$C_ACP_F64, 0, 0},
 {"UCX", DVI$C_ACP_UCX, 0, 0},
 {"F11V5", DVI$C_ACP_F11V5, 0, 0},
 {"", 0, 0, 0}};

struct item_code jpi_items[] = {
 {"ACCOUNT", JPI$_ACCOUNT, TEXT, 8},
 {"APTCNT", JPI$_APTCNT, LONG, 4},
 {"ASTACT", JPI$_ASTACT, LONG, 4},
 {"ASTCNT", JPI$_ASTCNT, LONG, 4},
 {"ASTEN", JPI$_ASTEN, LONG, 4},
 {"ASTLM", JPI$_ASTLM, LONG, 4},
 {"AUTHPRI", JPI$_AUTHPRI, LONG, 4},
 {"AUTHPRIV", JPI$_AUTHPRIV, PRIV, 8},
 {"BIOCNT", JPI$_BIOCNT, LONG, 4},
 {"BIOLM", JPI$_BIOLM, LONG, 4},
 {"BUFIO", JPI$_BUFIO, LONG, 4},
 {"BYTCNT", JPI$_BYTCNT, LONG, 4},
 {"BYTLM", JPI$_BYTLM, LONG, 4},
 {"CLASSIFICATION", JPI$_CLASSIFICATION, TEXT, 16},
 {"CLINAME", JPI$_CLINAME, TEXT, 39},
 {"CPULIM", JPI$_CPULIM, LONG, 4},
 {"CPUTIM", JPI$_CPUTIM, LONG, 4},
 {"CPU_ID", JPI$_CPU_ID, BYTE, 4},
 {"CREPRC_FLAGS", JPI$_CREPRC_FLAGS, LONG, 4},
 {"CURPRIV", JPI$_CURPRIV, PRIV, 8},
 {"CURRENT_AFFINITY_MASK", JPI$_CURRENT_AFFINITY_MASK, BYTE, 4},
 {"CURRENT_CAP_MASK", JPI$_CURRENT_CAP_MASK, BYTE, 4},
 {"CURRENT_USERCAP_MASK", JPI$_CURRENT_USERCAP_MASK, BYTE, 4},
 {"DFPFC", JPI$_DFPFC, LONG, 4},
 {"DFWSCNT", JPI$_DFWSCNT, LONG, 4},
 {"DIOCNT", JPI$_DIOCNT, LONG, 4},
 {"DIOLM", JPI$_DIOLM, LONG, 4},
 {"DIRIO", JPI$_DIRIO, LONG, 4},
 {"EFCS", JPI$_EFCS, LONG, 4},
 {"EFCU", JPI$_EFCU, LONG, 4},
 {"EFWM", JPI$_EFWM, LONG, 4},
 {"ENQCNT", JPI$_ENQCNT, LONG, 4},
 {"ENQLM", JPI$_ENQLM, LONG, 4},
 {"EXCVEC", JPI$_EXCVEC, BYTE, 4},
 {"FAST_VP_SWITCH", JPI$_FAST_VP_SWITCH, LONG, 4},
 {"FILCNT", JPI$_FILCNT, LONG, 4},
 {"FILLM", JPI$_FILLM, LONG, 4},
 {"FINALEXC", JPI$_FINALEXC, BYTE, 4},
 {"FREP0VA", JPI$_FREP0VA, BYTE, 4},
 {"FREP1VA", JPI$_FREP1VA, BYTE, 4},
 {"FREPTECNT", JPI$_FREPTECNT, LONG, 4},
 {"GPGCNT", JPI$_GPGCNT, LONG, 4},
 {"GRP", JPI$_GRP, LONG, 4},
 {"HOME_RAD", JPI$_HOME_RAD, LONG, 4},
 {"IMAGECOUNT", JPI$_IMAGECOUNT, LONG, 4},
 {"IMAGE_AUTHPRIV", JPI$_IMAGE_AUTHPRIV, PRIV, 8},
 {"IMAGE_PERMPRIV", JPI$_IMAGE_PERMPRIV, PRIV, 8},
 {"IMAGE_RIGHTS", JPI$_IMAGE_RIGHTS, RLST, 8},
 {"IMAGE_WORKPRIV", JPI$_IMAGE_WORKPRIV, PRIV, 8},
 {"IMAGNAME", JPI$_IMAGNAME, TEXT, 256},
 {"IMAGPRIV", JPI$_IMAGPRIV, PRIV, 8},
 {"INITIAL_THREAD_PID", JPI$_INITIAL_THREAD_PID, BYTE, 4},
 {"INSTALL_RIGHTS", JPI$_INSTALL_RIGHTS, RLST, 8},
 {"INSTALL_RIGHTS_SIZE", JPI$_INSTALL_RIGHTS_SIZE, LONG, 4},
 {"JOBPRCCNT", JPI$_JOBPRCCNT, LONG, 4},
 {"JOBTYPE", JPI$_JOBTYPE, LONG, 4},
 {"KT_COUNT", JPI$_KT_COUNT, LONG, 4},
 {"LAST_LOGIN_I", JPI$_LAST_LOGIN_I, DATE, 8},
 {"LAST_LOGIN_N", JPI$_LAST_LOGIN_N, DATE, 8},
 {"LOGINTIM", JPI$_LOGINTIM, DATE, 8},
 {"LOGIN_FAILURES", JPI$_LOGIN_FAILURES, LONG, 4},
 {"LOGIN_FLAGS", JPI$_LOGIN_FLAGS, LONG, 4},
 {"MASTER_PID", JPI$_MASTER_PID, BYTE, 4},
 {"MAXDETACH", JPI$_MAXDETACH, LONG, 4},
 {"MAXJOBS", JPI$_MAXJOBS, LONG, 4},
 {"MEM", JPI$_MEM, LONG, 4},
 {"MODE", JPI$_MODE, LONG, 4},
 {"MSGMASK", JPI$_MSGMASK, LONG, 4},
 {"MULTITHREAD", JPI$_MULTITHREAD, LONG, 4},
 {"NODENAME", JPI$_NODENAME, TEXT, 15},
 {"NODE_CSID", JPI$_NODE_CSID, BYTE, 4},
 {"NODE_VERSION", JPI$_NODE_VERSION, TEXT, 4},
 {"OWNER", JPI$_OWNER, BYTE, 4},
 {"P0_FIRST_FREE_VA_64", JPI$_P0_FIRST_FREE_VA_64, BYTE, 4},
 {"P1_FIRST_FREE_VA_64", JPI$_P1_FIRST_FREE_VA_64, BYTE, 4},
 {"P2_FIRST_FREE_VA_64", JPI$_P2_FIRST_FREE_VA_64, BYTE, 4},
 {"PAGEFLTS", JPI$_PAGEFLTS, LONG, 4},
 {"PAGFILCNT", JPI$_PAGFILCNT, LONG, 4},
 {"PAGFILLOC", JPI$_PAGFILLOC, LONG, 4},
 {"PARSE_STYLE_IMAGE", JPI$_PARSE_STYLE_IMAGE, LONG, 4},
 {"PARSE_STYLE_PERM", JPI$_PARSE_STYLE_PERM, LONG, 4},
 {"PERMANENT_AFFINITY_MASK", JPI$_PERMANENT_AFFINITY_MASK, BYTE, 4},
 {"PERMANENT_CAP_MASK", JPI$_PERMANENT_CAP_MASK, BYTE, 4},
 {"PERMANENT_USERCAP_MASK", JPI$_PERMANENT_USERCAP_MASK, BYTE, 4},
 {"PERSONA_AUTHPRIV", JPI$_PERSONA_AUTHPRIV, PRIV, 8},
 {"PERSONA_ID", JPI$_PERSONA_ID, LONG, 4},
 {"PERSONA_PERMPRIV", JPI$_PERSONA_PERMPRIV, PRIV, 8},
 {"PERSONA_RIGHTS", JPI$_PERSONA_RIGHTS, RLST, 8},
 {"PERSONA_RIGHTS_SIZE", JPI$_PERSONA_RIGHTS_SIZE, LONG, 4},
 {"PERSONA_WORKPRIV", JPI$_PERSONA_WORKPRIV, PRIV, 8},
 {"PGFLQUOTA", JPI$_PGFLQUOTA, LONG, 4},
 {"PHDFLAGS", JPI$_PHDFLAGS, LONG, 4},
 {"PID", JPI$_PID, BYTE, 4},
 {"PPGCNT", JPI$_PPGCNT, LONG, 4},
 {"PRCCNT", JPI$_PRCCNT, LONG, 4},
 {"PRCLM", JPI$_PRCLM, LONG, 4},
 {"PRCNAM", JPI$_PRCNAM, TEXT, 15},
 {"PRI", JPI$_PRI, LONG, 4},
 {"PRIB", JPI$_PRIB, LONG, 4},
 {"PROCESS_RIGHTS", JPI$_PROCESS_RIGHTS, RLST, 8},
 {"PROCPRIV", JPI$_PROCPRIV, PRIV, 8},
 {"PROC_INDEX", JPI$_PROC_INDEX, LONG, 4},
 {"RIGHTSLIST", JPI$_RIGHTSLIST, RLST, 8},
 {"RIGHTS_SIZE", JPI$_RIGHTS_SIZE, LONG, 4},
 {"RMS_DFLRL", JPI$_RMS_DFLRL, LONG, 4},
 {"RMS_DFMBC", JPI$_RMS_DFMBC, LONG, 4},
 {"RMS_DFMBFIDX", JPI$_RMS_DFMBFIDX, LONG, 4},
 {"RMS_DFMBFREL", JPI$_RMS_DFMBFREL, LONG, 4},
 {"RMS_DFMBFSDK", JPI$_RMS_DFMBFSDK, LONG, 4},
 {"RMS_DFMBFSMT", JPI$_RMS_DFMBFSMT, LONG, 4},
 {"RMS_DFMBFSUR", JPI$_RMS_DFMBFSUR, LONG, 4},
 {"RMS_DFNBC", JPI$_RMS_DFNBC, LONG, 4},
 {"RMS_EXTEND_SIZE", JPI$_RMS_EXTEND_SIZE, LONG, 4},
 {"RMS_FILEPROT", JPI$_RMS_FILEPROT, LONG, 4},
 {"RMS_HEURISTIC", JPI$_RMS_HEURISTIC, LONG, 4},
 {"RMS_PROLOGUE", JPI$_RMS_PROLOGUE, LONG, 4},
 {"RMS_QUERY_LOCK", JPI$_RMS_QUERY_LOCK, LONG, 4},
 {"SCHED_POLICY", JPI$_SCHED_POLICY, LONG, 4},
 {"SHRFILLM", JPI$_SHRFILLM, LONG, 4},
 {"SITESPEC", JPI$_SITESPEC, LONG, 4},
 {"SLOW_VP_SWITCH", JPI$_SLOW_VP_SWITCH, LONG, 4},
 {"STATE", JPI$_STATE, LONG, 4},
 {"STS", JPI$_STS, LONG, 4},
 {"STS2", JPI$_STS2, LONG, 4},
 {"SUBSYSTEM_RIGHTS", JPI$_SUBSYSTEM_RIGHTS, RLST, 8},
 {"SUBSYSTEM_RIGHTS_SIZE", JPI$_SUBSYSTEM_RIGHTS_SIZE, LONG, 4},
 {"SWPFILLOC", JPI$_SWPFILLOC, BYTE, 4},
 {"SYSTEM_RIGHTS", JPI$_SYSTEM_RIGHTS, RLST, 8},
 {"SYSTEM_RIGHTS_SIZE", JPI$_SYSTEM_RIGHTS_SIZE, LONG, 4},
 {"TABLENAME", JPI$_TABLENAME, TEXT, 255},
 {"TERMINAL", JPI$_TERMINAL, TEXT, 8},
 {"THREAD_INDEX", JPI$_THREAD_INDEX, LONG, 4},
 {"TMBU", JPI$_TMBU, LONG, 4},
 {"TQCNT", JPI$_TQCNT, LONG, 4},
 {"TQLM", JPI$_TQLM, LONG, 4},
 {"TT_ACCPORNAM", JPI$_TT_ACCPORNAM, TEXT, 255},
 {"TT_PHYDEVNAM", JPI$_TT_PHYDEVNAM, TEXT, 8},
 {"UAF_FLAGS", JPI$_UAF_FLAGS, LONG, 4},
 {"UIC", JPI$_UIC, UIC, 4},
 {"USERNAME", JPI$_USERNAME, TEXT, 12},
 {"VIRTPEAK", JPI$_VIRTPEAK, LONG, 4},
 {"VOLUMES", JPI$_VOLUMES, LONG, 4},
 {"VP_CONSUMER", JPI$_VP_CONSUMER, BOOL, 4},
 {"VP_CPUTIM", JPI$_VP_CPUTIM, LONG, 4},
 {"WSAUTH", JPI$_WSAUTH, LONG, 4},
 {"WSAUTHEXT", JPI$_WSAUTHEXT, LONG, 4},
 {"WSEXTENT", JPI$_WSEXTENT, LONG, 4},
 {"WSPEAK", JPI$_WSPEAK, LONG, 4},
 {"WSQUOTA", JPI$_WSQUOTA, LONG, 4},
 {"WSSIZE", JPI$_WSSIZE, LONG, 4},
 {"", 0, 0, 0}};

struct item_code jpi_modes[] = {
 {"OTHER", JPI$K_OTHER, 0, 0},
 {"NETWORK", JPI$K_NETWORK, 0, 0},
 {"BATCH", JPI$K_BATCH, 0, 0},
 {"INTERACTIVE", JPI$K_INTERACTIVE, 0, 0},
 {"", 0, 0, 0}};

struct item_code jpi_parse[] = {
 {"TRADITIONAL", PARSE_STYLE$C_TRADITIONAL, 0, 0},
 {"EXATENDED", PARSE_STYLE$C_EXTENDED, 0, 0},
 {"", 0, 0, 0}};

struct item_code jpi_states[] = {
 {"COLPG", SCH$C_COLPG, 0, 0},
 {"MWAIT", SCH$C_MWAIT, 0, 0},
 {"CEF", SCH$C_CEF, 0, 0},
 {"PFW", SCH$C_PFW, 0, 0},
 {"LEF", SCH$C_LEF, 0, 0},
 {"LEFO", SCH$C_LEFO, 0, 0},
 {"HIB", SCH$C_HIB, 0, 0},
 {"HIBO", SCH$C_HIBO, 0, 0},
 {"SUSP", SCH$C_SUSP, 0, 0},
 {"SUSPO", SCH$C_SUSPO, 0, 0},
 {"FPG", SCH$C_FPG, 0, 0},
 {"COM", SCH$C_COM, 0, 0},
 {"COMO", SCH$C_COMO, 0, 0},
 {"CUR", SCH$C_CUR, 0, 0},
 {"", 0, 0, 0}};

struct item_code syi_items[] = {
 {"ACP_BASEPRIO", SYI$_ACP_BASEPRIO, LONG, 4},
 {"ACP_DATACHECK", SYI$_ACP_DATACHECK, LONG, 4},
 {"ACP_DINDXCACHE", SYI$_ACP_DINDXCACHE, LONG, 4},
 {"ACP_DIRCACHE", SYI$_ACP_DIRCACHE, LONG, 4},
 {"ACP_EXTCACHE", SYI$_ACP_EXTCACHE, LONG, 4},
 {"ACP_EXTLIMIT", SYI$_ACP_EXTLIMIT, LONG, 4},
 {"ACP_FIDCACHE", SYI$_ACP_FIDCACHE, LONG, 4},
 {"ACP_HDRCACHE", SYI$_ACP_HDRCACHE, LONG, 4},
 {"ACP_MAPCACHE", SYI$_ACP_MAPCACHE, LONG, 4},
 {"ACP_MAXREAD", SYI$_ACP_MAXREAD, LONG, 4},
 {"ACP_MULTIPLE", SYI$_ACP_MULTIPLE, BOOL, 4},
 {"ACP_QUOCACHE", SYI$_ACP_QUOCACHE, LONG, 4},
 {"ACP_REBLDSYSD", SYI$_ACP_REBLDSYSD, BOOL, 4},
 {"ACP_SHARE", SYI$_ACP_SHARE, BOOL, 4},
 {"ACP_SWAPFLGS", SYI$_ACP_SWAPFLGS, LONG, 4},
 {"ACP_SYSACC", SYI$_ACP_SYSACC, LONG, 4},
 {"ACP_WINDOW", SYI$_ACP_WINDOW, LONG, 4},
 {"ACP_WORKSET", SYI$_ACP_WORKSET, LONG, 4},
 {"ACP_WRITEBACK", SYI$_ACP_WRITEBACK, LONG, 4},
 {"ACP_XQP_RES", SYI$_ACP_XQP_RES, BOOL, 4},
 {"ACTIVECPU_CNT", SYI$_ACTIVECPU_CNT, LONG, 4},
 {"ACTIVE_CPU_MASK", SYI$_ACTIVE_CPU_MASK, LONG, 4},
 {"AFFINITY_SKIP", SYI$_AFFINITY_SKIP, LONG, 4},
 {"AFFINITY_TIME", SYI$_AFFINITY_TIME, LONG, 4},
 {"ALLOCLASS", SYI$_ALLOCLASS, LONG, 4},
 {"ARB_SUPPORT", SYI$_ARB_SUPPORT, LONG, 4},
 {"ARCHFLAG", SYI$_ARCHFLAG, LONG, 4},
 {"ARCH_NAME", SYI$_ARCH_NAME, TEXT, 15},
 {"ARCH_TYPE", SYI$_ARCH_TYPE, LONG, 4},
 {"AVAILCPU_CNT", SYI$_AVAILCPU_CNT, LONG, 4},
 {"AVAIL_CPU_MASK", SYI$_AVAIL_CPU_MASK, LONG, 4},
 {"AVAIL_PAGES", SYI$_AVAIL_PAGES, LONG, 4},
 {"AWSMIN", SYI$_AWSMIN, LONG, 4},
 {"AWSMIN_SYS", SYI$_AWSMIN_SYS, LONG, 4},
 {"AWSTIME", SYI$_AWSTIME, LONG, 4},
 {"AWSTIME_SYS", SYI$_AWSTIME_SYS, LONG, 4},
 {"BALSETCNT", SYI$_BALSETCNT, LONG, 4},
 {"BAL_SLOTS", SYI$_BAL_SLOTS, BYTE, 16},
 {"BAP_MAX_PA_REG", SYI$_BAP_MAX_PA_REG, LONG, 4},
 {"BAP_MAX_REQ_SZ", SYI$_BAP_MAX_REQ_SZ, LONG, 4},
 {"BAP_MIN_PA_REG", SYI$_BAP_MIN_PA_REG, LONG, 4},
 {"BAP_MIN_REQ_SZ", SYI$_BAP_MIN_REQ_SZ, LONG, 4},
 {"BJOBLIM", SYI$_BJOBLIM, LONG, 4},
 {"BOOTTIME", SYI$_BOOTTIME, DATE, 8},
 {"BOOT_STYLE", SYI$_BOOT_STYLE, LONG, 4},
 {"BORROWLIM", SYI$_BORROWLIM, LONG, 4},
 {"BREAKPOINTS", SYI$_BREAKPOINTS, LONG, 4},
 {"BUGCHECKFATAL", SYI$_BUGCHECKFATAL, BOOL, 4},
 {"BUGREBOOT", SYI$_BUGREBOOT, BOOL, 4},
 {"CHANNELCNT", SYI$_CHANNELCNT, LONG, 4},
 {"CHARACTER_EMULATED", SYI$_CHARACTER_EMULATED, BOOL, 1},
 {"CLASS_PROT", SYI$_CLASS_PROT, BOOL, 4},
 {"CLISYMTBL", SYI$_CLISYMTBL, LONG, 4},
 {"CLOCK_INTERVAL", SYI$_CLOCK_INTERVAL, LONG, 4},
 {"CLUSTER_CREDITS", SYI$_CLUSTER_CREDITS, LONG, 4},
 {"CLUSTER_EVOTES", SYI$_CLUSTER_EVOTES, LONG, 2},
 {"CLUSTER_FSYSID", SYI$_CLUSTER_FSYSID, BYTE, 6},
 {"CLUSTER_FTIME", SYI$_CLUSTER_FTIME, DATE, 8},
 {"CLUSTER_MEMBER", SYI$_CLUSTER_MEMBER, BOOL, 1},
 {"CLUSTER_NODES", SYI$_CLUSTER_NODES, LONG, 4},
 {"CLUSTER_NTIME", SYI$_CLUSTER_NTIME, DATE, 8},
 {"CLUSTER_NTIME_REF", SYI$_CLUSTER_NTIME_REF, DATE, 8},
 {"CLUSTER_QUORUM", SYI$_CLUSTER_QUORUM, LONG, 4},
 {"CLUSTER_VOTES", SYI$_CLUSTER_VOTES, LONG, 4},
 {"COMMUNITY_ID", SYI$_COMMUNITY_ID, LONG, 4},
 {"CONCEAL_DEVICES", SYI$_CONCEAL_DEVICES, BOOL, 4},
 {"CONSOLE_VERSION", SYI$_CONSOLE_VERSION, TEXT, 16},
 {"CONTIG_GBLPAGES", SYI$_CONTIG_GBLPAGES, LONG, 4},
 {"CPU", SYI$_CPU, LONG, 4},
 {"CPUCAP_MASK", SYI$_CPUCAP_MASK, BYTE, 8},
 {"CPUCONF", SYI$_CPUCONF, LONG, 4},
 {"CPUTYPE", SYI$_CPUTYPE, LONG, 4},
 {"CPU_AUTOSTART", SYI$_CPU_AUTOSTART, BYTE, 1},
 {"CPU_FAILOVER", SYI$_CPU_FAILOVER, BYTE, 4},
 {"CRDENABLE", SYI$_CRDENABLE, BOOL, 4},
 {"CRD_CONTROL", SYI$_CRD_CONTROL, LONG, 4},
 {"CTLIMGLIM", SYI$_CTLIMGLIM, LONG, 4},
 {"CTLPAGES", SYI$_CTLPAGES, LONG, 4},
 {"CWCREPRC_ENABLE", SYI$_CWCREPRC_ENABLE, LONG, 4},
 {"CWLOGICALS", SYI$_CWLOGICALS, BOOL, 1},
 {"DAY_OVERRIDE", SYI$_DAY_OVERRIDE, BOOL, 1},
 {"DAY_SECONDARY", SYI$_DAY_SECONDARY, BOOL, 1},
 {"DBGTK_LOADED", SYI$_DBGTK_LOADED, BOOL, 4},
 {"DBGTK_SCRATCH", SYI$_DBGTK_SCRATCH, LONG, 4},
 {"DEADLOCK_WAIT", SYI$_DEADLOCK_WAIT, LONG, 4},
 {"DECIMAL_EMULATED", SYI$_DECIMAL_EMULATED, BOOL, 1},
 {"DECNET_FULLNAME", SYI$_DECNET_FULLNAME, TEXT, 255},
 {"DECNET_VERSION", SYI$_DECNET_VERSION, BYTE, 4},
 {"DEFMBXBUFQUO", SYI$_DEFMBXBUFQUO, LONG, 4},
 {"DEFMBXMXMSG", SYI$_DEFMBXMXMSG, LONG, 4},
 {"DEFPRI", SYI$_DEFPRI, LONG, 4},
 {"DEFQUEPRI", SYI$_DEFQUEPRI, LONG, 4},
 {"DEF_PRIO_MAX", SYI$_DEF_PRIO_MAX, LONG, 4},
 {"DEF_PRIO_MIN", SYI$_DEF_PRIO_MIN, LONG, 4},
 {"DEVICE_NAMING", SYI$_DEVICE_NAMING, LONG, 4},
 {"DISABLE_UPCALLS", SYI$_DISABLE_UPCALLS, LONG, 4},
 {"DISK_QUORUM", SYI$_DISK_QUORUM, TEXT, 16},
 {"DISMOUMSG", SYI$_DISMOUMSG, BOOL, 4},
 {"DLCKEXTRASTK", SYI$_DLCKEXTRASTK, LONG, 4},
 {"DNVOSI1", SYI$_DNVOSI1, LONG, 4},
 {"DORMANTWAIT", SYI$_DORMANTWAIT, LONG, 4},
 {"DR_UNIT_BASE", SYI$_DR_UNIT_BASE, LONG, 4},
 {"DUMPBUG", SYI$_DUMPBUG, BOOL, 4},
 {"DUMPSTYLE", SYI$_DUMPSTYLE, LONG, 4},
 {"D_FLOAT_EMULATED", SYI$_D_FLOAT_EMULATED, BOOL, 1},
 {"ERLBUFFERPAGES", SYI$_ERLBUFFERPAGES, LONG, 4},
 {"ERRORLOGBUFFERS", SYI$_ERRORLOGBUFFERS, LONG, 4},
 {"EXPECTED_VOTES", SYI$_EXPECTED_VOTES, LONG, 4},
 {"EXTRACPU", SYI$_EXTRACPU, LONG, 4},
 {"EXUSRSTK", SYI$_EXUSRSTK, LONG, 4},
 {"F64CTL1", SYI$_F64CTL1, LONG, 4},
 {"F64CTL2", SYI$_F64CTL2, LONG, 4},
 {"F64CTLD3", SYI$_F64CTLD3, LONG, 4},
 {"F64CTLD4", SYI$_F64CTLD4, LONG, 4},
 {"FAN_VECTOR", SYI$_FAN_VECTOR, BYTE, 16},
 {"FAST_PATH", SYI$_FAST_PATH, LONG, 4},
 {"FILE_CACHE", SYI$_FILE_CACHE, LONG, 4},
 {"FILE_CACHE_MAX", SYI$_FILE_CACHE_MAX, LONG, 4},
 {"FILE_CACHE_MIN", SYI$_FILE_CACHE_MIN, LONG, 4},
 {"FREEGOAL", SYI$_FREEGOAL, LONG, 4},
 {"FREELIM", SYI$_FREELIM, LONG, 4},
 {"FREE_GBLPAGES", SYI$_FREE_GBLPAGES, LONG, 4},
 {"FREE_GBLSECTS", SYI$_FREE_GBLSECTS, LONG, 4},
 {"FT_ACTIVE", SYI$_FT_ACTIVE, BOOL, 4},
 {"FT_FLAGS", SYI$_FT_FLAGS, LONG, 4},
 {"F_FLOAT_EMULATED", SYI$_F_FLOAT_EMULATED, BOOL, 1},
 {"GALAXY", SYI$_GALAXY, LONG, 4},
 {"GALAXY_ID", SYI$_GALAXY_ID, BYTE, 16},
 {"GALAXY_MEMBER", SYI$_GALAXY_MEMBER, LONG, 4},
 {"GALAXY_PLATFORM", SYI$_GALAXY_PLATFORM, LONG, 4},
 {"GALAXY_SHMEMSIZE", SYI$_GALAXY_SHMEMSIZE, LONG, 4},
 {"GBLPAGES", SYI$_GBLPAGES, LONG, 4},
 {"GBLPAGFIL", SYI$_GBLPAGFIL, LONG, 4},
 {"GBLSECTIONS", SYI$_GBLSECTIONS, LONG, 4},
 {"GH_EXEC_CODE", SYI$_GH_EXEC_CODE, LONG, 4},
 {"GH_EXEC_DATA", SYI$_GH_EXEC_DATA, LONG, 4},
 {"GH_RES_CODE", SYI$_GH_RES_CODE, LONG, 4},
 {"GH_RES_DATA", SYI$_GH_RES_DATA, LONG, 4},
 {"GH_RSRVPGCNT", SYI$_GH_RSRVPGCNT, LONG, 4},
 {"GLX_FORMATION", SYI$_GLX_FORMATION, DATE, 8},
 {"GLX_INCARNATION", SYI$_GLX_INCARNATION, BYTE, 8},
 {"GLX_INST_TMO", SYI$_GLX_INST_TMO, LONG, 4},
 {"GLX_MAX_MEMBERS", SYI$_GLX_MAX_MEMBERS, LONG, 4},
 {"GLX_MBR_INCARNATION", SYI$_GLX_MBR_INCARNATION, TEXT, 1},
 {"GLX_MBR_JOINED", SYI$_GLX_MBR_JOINED, TEXT, 15},
 {"GLX_MBR_MEMBER", SYI$_GLX_MBR_MEMBER, TEXT, 15},
 {"GLX_MBR_NAME", SYI$_GLX_MBR_NAME, TEXT, 15},
 {"GLX_SHM_REG", SYI$_GLX_SHM_REG, LONG, 4},
 {"GLX_SW_VERSION", SYI$_GLX_SW_VERSION, LONG, 4},
 {"GLX_TERMINATION", SYI$_GLX_TERMINATION, DATE, 8},
 {"GROWLIM", SYI$_GROWLIM, LONG, 4},
 {"G_FLOAT_EMULATED", SYI$_G_FLOAT_EMULATED, BOOL, 1},
 {"HP_ACTIVE_CPU_CNT", SYI$_HP_ACTIVE_CPU_CNT, LONG, 4},
 {"HP_ACTIVE_SP_CNT", SYI$_HP_ACTIVE_SP_CNT, LONG, 4},
 {"HP_CONFIG_SBB_CNT", SYI$_HP_CONFIG_SBB_CNT, LONG, 4},
 {"HP_CONFIG_SP_CNT", SYI$_HP_CONFIG_SP_CNT, LONG, 4},
 {"HW_MODEL", SYI$_HW_MODEL, LONG, 2},
 {"HW_NAME", SYI$_HW_NAME, TEXT, 31},
 {"H_FLOAT_EMULATED", SYI$_H_FLOAT_EMULATED, BOOL, 1},
 {"IEEE_ADDRESS", SYI$_IEEE_ADDRESS, LONG, 4},
 {"IEEE_ADDRESSH", SYI$_IEEE_ADDRESSH, LONG, 4},
 {"IJOBLIM", SYI$_IJOBLIM, LONG, 4},
 {"IMGIOCNT", SYI$_IMGIOCNT, LONG, 4},
 {"IMGREG_PAGES", SYI$_IMGREG_PAGES, LONG, 4},
 {"IOTA", SYI$_IOTA, LONG, 4},
 {"IO_PREFER_CPUS", SYI$_IO_PREFER_CPUS, LONG, 4},
 {"IRPCOUNT", SYI$_IRPCOUNT, LONG, 4},
 {"IRPCOUNTV", SYI$_IRPCOUNTV, LONG, 4},
 {"ITB_ENTRIES", SYI$_ITB_ENTRIES, LONG, 4},
 {"JOBCTLD", SYI$_JOBCTLD, LONG, 4},
 {"KFILSTCNT", SYI$_KFILSTCNT, LONG, 4},
 {"KSTACKPAGES", SYI$_KSTACKPAGES, LONG, 4},
 {"LAMAPREGS", SYI$_LAMAPREGS, LONG, 4},
 {"LAN_FLAGS", SYI$_LAN_FLAGS, LONG, 4},
 {"LCKMGR_CPUID", SYI$_LCKMGR_CPUID, BOOL, 4},
 {"LCKMGR_MODE", SYI$_LCKMGR_MODE, BOOL, 4},
 {"LCKMGR_RSVD", SYI$_LCKMGR_RSVD, BOOL, 4},
 {"LGI_BRK_DISUSER", SYI$_LGI_BRK_DISUSER, BOOL, 4},
 {"LGI_BRK_LIM", SYI$_LGI_BRK_LIM, LONG, 4},
 {"LGI_BRK_TERM", SYI$_LGI_BRK_TERM, BOOL, 4},
 {"LGI_BRK_TMO", SYI$_LGI_BRK_TMO, LONG, 4},
 {"LGI_CALLOUTS", SYI$_LGI_CALLOUTS, LONG, 4},
 {"LGI_HID_TIM", SYI$_LGI_HID_TIM, LONG, 4},
 {"LGI_PWD_TMO", SYI$_LGI_PWD_TMO, LONG, 4},
 {"LGI_RETRY_LIM", SYI$_LGI_RETRY_LIM, LONG, 4},
 {"LGI_RETRY_TMO", SYI$_LGI_RETRY_TMO, LONG, 4},
 {"LNMPHASHTBL", SYI$_LNMPHASHTBL, LONG, 4},
 {"LNMSHASHTBL", SYI$_LNMSHASHTBL, LONG, 4},
 {"LOAD_PWD_POLICY", SYI$_LOAD_PWD_POLICY, BOOL, 4},
 {"LOAD_SYS_IMAGES", SYI$_LOAD_SYS_IMAGES, BOOL, 4},
 {"LOCKDIRWT", SYI$_LOCKDIRWT, LONG, 4},
 {"LOCKIDTBL", SYI$_LOCKIDTBL, LONG, 4},
 {"LOCKIDTBL_MAX", SYI$_LOCKIDTBL_MAX, LONG, 4},
 {"LOCKRETRY", SYI$_LOCKRETRY, LONG, 4},
 {"LONGWAIT", SYI$_LONGWAIT, LONG, 4},
 {"LRPCOUNT", SYI$_LRPCOUNT, LONG, 4},
 {"LRPCOUNTV", SYI$_LRPCOUNTV, LONG, 4},
 {"LRPMIN", SYI$_LRPMIN, LONG, 4},
 {"LRPSIZE", SYI$_LRPSIZE, LONG, 4},
 {"MAIN_MEMORY", SYI$_MAIN_MEMORY, BYTE, 16},
 {"MAXBOBMEM", SYI$_MAXBOBMEM, LONG, 4},
 {"MAXBOBS0S1", SYI$_MAXBOBS0S1, LONG, 4},
 {"MAXBOBS2", SYI$_MAXBOBS2, LONG, 4},
 {"MAXBUF", SYI$_MAXBUF, LONG, 4},
 {"MAXCLASSPRI", SYI$_MAXCLASSPRI, LONG, 4},
 {"MAXPROCESSCNT", SYI$_MAXPROCESSCNT, LONG, 4},
 {"MAXQUEPRI", SYI$_MAXQUEPRI, LONG, 4},
 {"MAXSYSGROUP", SYI$_MAXSYSGROUP, LONG, 4},
 {"MAX_CPUS", SYI$_MAX_CPUS, LONG, 4},
 {"MAX_PFN", SYI$_MAX_PFN, LONG, 4},
 {"MC_SERVICES_P0", SYI$_MC_SERVICES_P0, LONG, 4},
 {"MC_SERVICES_P1", SYI$_MC_SERVICES_P1, LONG, 4},
 {"MC_SERVICES_P2", SYI$_MC_SERVICES_P2, LONG, 4},
 {"MC_SERVICES_P3", SYI$_MC_SERVICES_P3, LONG, 4},
 {"MC_SERVICES_P4", SYI$_MC_SERVICES_P4, LONG, 4},
 {"MC_SERVICES_P5", SYI$_MC_SERVICES_P5, LONG, 4},
 {"MC_SERVICES_P6", SYI$_MC_SERVICES_P6, LONG, 4},
 {"MC_SERVICES_P7", SYI$_MC_SERVICES_P7, LONG, 4},
 {"MC_SERVICES_P8", SYI$_MC_SERVICES_P8, LONG, 4},
 {"MC_SERVICES_P9", SYI$_MC_SERVICES_P9, LONG, 4},
 {"MEMSIZE", SYI$_MEMSIZE, LONG, 4},
 {"MINCLASSPRI", SYI$_MINCLASSPRI, LONG, 4},
 {"MINPRPRI", SYI$_MINPRPRI, LONG, 4},
 {"MINWSCNT", SYI$_MINWSCNT, LONG, 4},
 {"MMG_CTLFLAGS", SYI$_MMG_CTLFLAGS, LONG, 4},
 {"MOUNTMSG", SYI$_MOUNTMSG, BOOL, 4},
 {"MPDEV_AFB_INTVL", SYI$_MPDEV_AFB_INTVL, LONG, 4},
 {"MPDEV_D1", SYI$_MPDEV_D1, LONG, 4},
 {"MPDEV_D2", SYI$_MPDEV_D2, LONG, 4},
 {"MPDEV_D3", SYI$_MPDEV_D3, LONG, 4},
 {"MPDEV_D4", SYI$_MPDEV_D4, LONG, 4},
 {"MPDEV_ENABLE", SYI$_MPDEV_ENABLE, BOOL, 4},
 {"MPDEV_LCRETRIES", SYI$_MPDEV_LCRETRIES, LONG, 4},
 {"MPDEV_POLLER", SYI$_MPDEV_POLLER, BOOL, 4},
 {"MPDEV_REMOTE", SYI$_MPDEV_REMOTE, BOOL, 4},
 {"MPW_HILIMIT", SYI$_MPW_HILIMIT, LONG, 4},
 {"MPW_IOLIMIT", SYI$_MPW_IOLIMIT, LONG, 4},
 {"MPW_LOLIMIT", SYI$_MPW_LOLIMIT, LONG, 4},
 {"MPW_LOWAITLIMIT", SYI$_MPW_LOWAITLIMIT, LONG, 4},
 {"MPW_PRIO", SYI$_MPW_PRIO, LONG, 4},
 {"MPW_THRESH", SYI$_MPW_THRESH, LONG, 4},
 {"MPW_WAITLIMIT", SYI$_MPW_WAITLIMIT, LONG, 4},
 {"MPW_WRTCLUSTER", SYI$_MPW_WRTCLUSTER, LONG, 4},
 {"MSCP_BUFFER", SYI$_MSCP_BUFFER, LONG, 4},
 {"MSCP_CMD_TMO", SYI$_MSCP_CMD_TMO, LONG, 4},
 {"MSCP_CREDITS", SYI$_MSCP_CREDITS, LONG, 4},
 {"MSCP_LOAD", SYI$_MSCP_LOAD, LONG, 4},
 {"MSCP_SERVE_ALL", SYI$_MSCP_SERVE_ALL, LONG, 4},
 {"MULTIPROCESSING", SYI$_MULTIPROCESSING, LONG, 4},
 {"MULTITHREAD", SYI$_MULTITHREAD, LONG, 4},
 {"MVTIMEOUT", SYI$_MVTIMEOUT, LONG, 4},
 {"NET_CALLOUTS", SYI$_NET_CALLOUTS, LONG, 4},
 {"NISCS_CONV_BOOT", SYI$_NISCS_CONV_BOOT, BOOL, 4},
 {"NISCS_LAN_OVRHD", SYI$_NISCS_LAN_OVRHD, LONG, 4},
 {"NISCS_LOAD_PEA0", SYI$_NISCS_LOAD_PEA0, BOOL, 4},
 {"NISCS_MAX_PKTSZ", SYI$_NISCS_MAX_PKTSZ, LONG, 4},
 {"NISCS_PORT_SERV", SYI$_NISCS_PORT_SERV, LONG, 4},
 {"NJOBLIM", SYI$_NJOBLIM, LONG, 4},
 {"NOAUTOCONFIG", SYI$_NOAUTOCONFIG, BOOL, 4},
 {"NOCLUSTER", SYI$_NOCLUSTER, BOOL, 4},
 {"NODENAME", SYI$_NODENAME, TEXT, 15},
 {"NODE_AREA", SYI$_NODE_AREA, LONG, 4},
 {"NODE_CSID", SYI$_NODE_CSID, BYTE, 4},
 {"NODE_EVOTES", SYI$_NODE_EVOTES, LONG, 2},
 {"NODE_HWTYPE", SYI$_NODE_HWTYPE, TEXT, 4},
 {"NODE_HWVERS", SYI$_NODE_HWVERS, BYTE, 12},
 {"NODE_NUMBER", SYI$_NODE_NUMBER, LONG, 4},
 {"NODE_QUORUM", SYI$_NODE_QUORUM, LONG, 4},
 {"NODE_SWINCARN", SYI$_NODE_SWINCARN, BYTE, 8},
 {"NODE_SWTYPE", SYI$_NODE_SWTYPE, TEXT, 4},
 {"NODE_SWVERS", SYI$_NODE_SWVERS, TEXT, 4},
 {"NODE_SYSTEMID", SYI$_NODE_SYSTEMID, BYTE, 6},
 {"NODE_VOTES", SYI$_NODE_VOTES, LONG, 4},
 {"NOPGFLSWP", SYI$_NOPGFLSWP, BOOL, 4},
 {"NPAGECALC", SYI$_NPAGECALC, LONG, 4},
 {"NPAGEDYN", SYI$_NPAGEDYN, LONG, 4},
 {"NPAGED_POOL", SYI$_NPAGED_POOL, BYTE, 16},
 {"NPAGEVIR", SYI$_NPAGEVIR, LONG, 4},
 {"NPAG_AGGRESSIVE", SYI$_NPAG_AGGRESSIVE, LONG, 4},
 {"NPAG_BAP_MAX", SYI$_NPAG_BAP_MAX, LONG, 4},
 {"NPAG_BAP_MAX_PA", SYI$_NPAG_BAP_MAX_PA, LONG, 4},
 {"NPAG_BAP_MIN", SYI$_NPAG_BAP_MIN, LONG, 4},
 {"NPAG_BAP_MIN_PA", SYI$_NPAG_BAP_MIN_PA, LONG, 4},
 {"NPAG_GENTLE", SYI$_NPAG_GENTLE, LONG, 4},
 {"NPAG_INTERVAL", SYI$_NPAG_INTERVAL, LONG, 4},
 {"NPAG_RING_SIZE", SYI$_NPAG_RING_SIZE, LONG, 4},
 {"PAGEDYN", SYI$_PAGEDYN, LONG, 4},
 {"PAGED_POOL", SYI$_PAGED_POOL, BYTE, 16},
 {"PAGEFILE_FREE", SYI$_PAGEFILE_FREE, LONG, 4},
 {"PAGEFILE_PAGE", SYI$_PAGEFILE_PAGE, LONG, 4},
 {"PAGE_SIZE", SYI$_PAGE_SIZE, LONG, 4},
 {"PAGFILCNT", SYI$_PAGFILCNT, LONG, 4},
 {"PAGTBLPFC", SYI$_PAGTBLPFC, LONG, 4},
 {"PALCODE_VERSION", SYI$_PALCODE_VERSION, TEXT, 16},
 {"PAMAXPORT", SYI$_PAMAXPORT, LONG, 4},
 {"PANOPOLL", SYI$_PANOPOLL, LONG, 4},
 {"PANUMPOLL", SYI$_PANUMPOLL, LONG, 4},
 {"PAPOLLINTERVAL", SYI$_PAPOLLINTERVAL, LONG, 4},
 {"PAPOOLINTERVAL", SYI$_PAPOOLINTERVAL, LONG, 4},
 {"PARTITION_ID", SYI$_PARTITION_ID, LONG, 4},
 {"PASANITY", SYI$_PASANITY, LONG, 4},
 {"PASTDGBUF", SYI$_PASTDGBUF, LONG, 4},
 {"PASTIMOUT", SYI$_PASTIMOUT, LONG, 4},
 {"PE1", SYI$_PE1, LONG, 4},
 {"PE2", SYI$_PE2, LONG, 4},
 {"PE3", SYI$_PE3, LONG, 4},
 {"PE4", SYI$_PE4, LONG, 4},
 {"PE5", SYI$_PE5, LONG, 4},
 {"PE6", SYI$_PE6, LONG, 4},
 {"PFCDEFAULT", SYI$_PFCDEFAULT, LONG, 4},
 {"PFN_COLOR_COUNT", SYI$_PFN_COLOR_COUNT, LONG, 4},
 {"PFN_MEMORY_MAP", SYI$_PFN_MEMORY_MAP, BYTE, 64},
 {"PFRATH", SYI$_PFRATH, LONG, 4},
 {"PFRATH_SYS", SYI$_PFRATH_SYS, LONG, 4},
 {"PFRATL", SYI$_PFRATL, LONG, 4},
 {"PFRATL_SYS", SYI$_PFRATL_SYS, LONG, 4},
 {"PHYSICALPAGES", SYI$_PHYSICALPAGES, LONG, 4},
 {"PHYSICAL_MEMORY", SYI$_PHYSICAL_MEMORY, LONG, 4},
 {"PIOPAGES", SYI$_PIOPAGES, LONG, 4},
 {"PIXSCAN", SYI$_PIXSCAN, LONG, 4},
 {"PMD_COUNT", SYI$_PMD_COUNT, LONG, 4},
 {"POOLCHECK", SYI$_POOLCHECK, LONG, 4},
 {"POOLPAGING", SYI$_POOLPAGING, BOOL, 4},
 {"POTENTIALCPU_CNT", SYI$_POTENTIALCPU_CNT, LONG, 4},
 {"POTENTIAL_CPU_MASK", SYI$_POTENTIAL_CPU_MASK, LONG, 4},
 {"POWEROFF", SYI$_POWEROFF, BOOL, 4},
 {"POWER_VECTOR", SYI$_POWER_VECTOR, BYTE, 16},
 {"PQL_DASTLM", SYI$_PQL_DASTLM, LONG, 4},
 {"PQL_DBIOLM", SYI$_PQL_DBIOLM, LONG, 4},
 {"PQL_DBYTLM", SYI$_PQL_DBYTLM, LONG, 4},
 {"PQL_DCPULM", SYI$_PQL_DCPULM, LONG, 4},
 {"PQL_DDIOLM", SYI$_PQL_DDIOLM, LONG, 4},
 {"PQL_DENQLM", SYI$_PQL_DENQLM, LONG, 4},
 {"PQL_DFILLM", SYI$_PQL_DFILLM, LONG, 4},
 {"PQL_DJTQUOTA", SYI$_PQL_DJTQUOTA, LONG, 4},
 {"PQL_DPGFLQUOTA", SYI$_PQL_DPGFLQUOTA, LONG, 4},
 {"PQL_DPRCLM", SYI$_PQL_DPRCLM, LONG, 4},
 {"PQL_DTQELM", SYI$_PQL_DTQELM, LONG, 4},
 {"PQL_DWSDEFAULT", SYI$_PQL_DWSDEFAULT, LONG, 4},
 {"PQL_DWSEXTENT", SYI$_PQL_DWSEXTENT, LONG, 4},
 {"PQL_DWSQUOTA", SYI$_PQL_DWSQUOTA, LONG, 4},
 {"PQL_MASTLM", SYI$_PQL_MASTLM, LONG, 4},
 {"PQL_MBIOLM", SYI$_PQL_MBIOLM, LONG, 4},
 {"PQL_MBYTLM", SYI$_PQL_MBYTLM, LONG, 4},
 {"PQL_MCPULM", SYI$_PQL_MCPULM, LONG, 4},
 {"PQL_MDIOLM", SYI$_PQL_MDIOLM, LONG, 4},
 {"PQL_MENQLM", SYI$_PQL_MENQLM, LONG, 4},
 {"PQL_MFILLM", SYI$_PQL_MFILLM, LONG, 4},
 {"PQL_MJTQUOTA", SYI$_PQL_MJTQUOTA, LONG, 4},
 {"PQL_MPGFLQUOTA", SYI$_PQL_MPGFLQUOTA, LONG, 4},
 {"PQL_MPRCLM", SYI$_PQL_MPRCLM, LONG, 4},
 {"PQL_MTQELM", SYI$_PQL_MTQELM, LONG, 4},
 {"PQL_MWSDEFAULT", SYI$_PQL_MWSDEFAULT, LONG, 4},
 {"PQL_MWSEXTENT", SYI$_PQL_MWSEXTENT, LONG, 4},
 {"PQL_MWSQUOTA", SYI$_PQL_MWSQUOTA, LONG, 4},
 {"PRCPOLINTERVAL", SYI$_PRCPOLINTERVAL, LONG, 4},
 {"PRIMARY_CPUID", SYI$_PRIMARY_CPUID, LONG, 4},
 {"PRIORITY_OFFSET", SYI$_PRIORITY_OFFSET, LONG, 4},
 {"PROCESS_SPACE_LIMIT", SYI$_PROCESS_SPACE_LIMIT, BYTE, 8},
 {"PROCSECTCNT", SYI$_PROCSECTCNT, LONG, 4},
 {"PROC_SLOTS", SYI$_PROC_SLOTS, BYTE, 16},
 {"PSEUDOLOA", SYI$_PSEUDOLOA, LONG, 4},
 {"PSXFIFO_PRIO_MAX", SYI$_PSXFIFO_PRIO_MAX, LONG, 4},
 {"PSXFIFO_PRIO_MIN", SYI$_PSXFIFO_PRIO_MIN, LONG, 4},
 {"PSXRR_PRIO_MAX", SYI$_PSXRR_PRIO_MAX, LONG, 4},
 {"PSXRR_PRIO_MIN", SYI$_PSXRR_PRIO_MIN, LONG, 4},
 {"PTES_PER_PAGE", SYI$_PTES_PER_PAGE, LONG, 4},
 {"PT_BASE", SYI$_PT_BASE, BYTE, 8},
 {"PU_OPTIONS", SYI$_PU_OPTIONS, LONG, 4},
 {"QBUS_MULT_INTR", SYI$_QBUS_MULT_INTR, LONG, 4},
 {"QDSKINTERVAL", SYI$_QDSKINTERVAL, LONG, 4},
 {"QDSKVOTES", SYI$_QDSKVOTES, LONG, 4},
 {"QUANTUM", SYI$_QUANTUM, LONG, 4},
 {"QUORUM", SYI$_QUORUM, LONG, 4},
 {"RAD_CPUS", SYI$_RAD_CPUS, BYTE, 8},
 {"RAD_MAX_RADS", SYI$_RAD_MAX_RADS, LONG, 4},
 {"RAD_MEMSIZE", SYI$_RAD_MEMSIZE, BYTE, 8},
 {"RAD_SHMEMSIZE", SYI$_RAD_SHMEMSIZE, BYTE, 8},
 {"RAD_SUPPORT", SYI$_RAD_SUPPORT, LONG, 4},
 {"REALTIME_SPTS", SYI$_REALTIME_SPTS, LONG, 4},
 {"REAL_CPUTYPE", SYI$_REAL_CPUTYPE, LONG, 4},
 {"RECNXINTERVAL", SYI$_RECNXINTERVAL, LONG, 4},
 {"RESALLOC", SYI$_RESALLOC, BOOL, 4},
 {"RESHASHTBL", SYI$_RESHASHTBL, LONG, 4},
 {"RJOBLIM", SYI$_RJOBLIM, LONG, 4},
 {"RMSD1", SYI$_RMSD1, LONG, 4},
 {"RMS_DFLRL", SYI$_RMS_DFLRL, LONG, 4},
 {"RMS_DFMBC", SYI$_RMS_DFMBC, LONG, 4},
 {"RMS_DFMBFIDX", SYI$_RMS_DFMBFIDX, LONG, 4},
 {"RMS_DFMBFREL", SYI$_RMS_DFMBFREL, LONG, 4},
 {"RMS_DFMBFSDK", SYI$_RMS_DFMBFSDK, LONG, 4},
 {"RMS_DFMBFSMT", SYI$_RMS_DFMBFSMT, LONG, 4},
 {"RMS_DFMBFSUR", SYI$_RMS_DFMBFSUR, LONG, 4},
 {"RMS_DFNBC", SYI$_RMS_DFNBC, LONG, 4},
 {"RMS_EXTEND_SIZE", SYI$_RMS_EXTEND_SIZE, LONG, 4},
 {"RMS_FILEPROT", SYI$_RMS_FILEPROT, LONG, 4},
 {"RMS_GBLBUFQUO", SYI$_RMS_GBLBUFQUO, LONG, 4},
 {"RMS_HEURISTIC", SYI$_RMS_HEURISTIC, LONG, 4},
 {"RMS_PROLOGUE", SYI$_RMS_PROLOGUE, LONG, 4},
 {"RSRVPAGCNT", SYI$_RSRVPAGCNT, LONG, 4},
 {"S0_PAGING", SYI$_S0_PAGING, LONG, 4},
 {"S2_SIZE", SYI$_S2_SIZE, LONG, 4},
 {"SAVEDUMP", SYI$_SAVEDUMP, BOOL, 4},
 {"SA_APP", SYI$_SA_APP, BOOL, 4},
 {"SBIERRENABLE", SYI$_SBIERRENABLE, BOOL, 4},
 {"SCH_CTLFLAGS", SYI$_SCH_CTLFLAGS, LONG, 4},
 {"SCSBUFFCNT", SYI$_SCSBUFFCNT, LONG, 4},
 {"SCSCONNCNT", SYI$_SCSCONNCNT, LONG, 4},
 {"SCSFLOWCUSH", SYI$_SCSFLOWCUSH, LONG, 4},
 {"SCSICLUSTER_P1", SYI$_SCSICLUSTER_P1, TEXT, 4},
 {"SCSICLUSTER_P2", SYI$_SCSICLUSTER_P2, TEXT, 4},
 {"SCSICLUSTER_P3", SYI$_SCSICLUSTER_P3, TEXT, 4},
 {"SCSICLUSTER_P4", SYI$_SCSICLUSTER_P4, TEXT, 4},
 {"SCSMAXDG", SYI$_SCSMAXDG, LONG, 4},
 {"SCSMAXMSG", SYI$_SCSMAXMSG, LONG, 4},
 {"SCSNODE", SYI$_SCSNODE, TEXT, 8},
 {"SCSRESPCNT", SYI$_SCSRESPCNT, LONG, 4},
 {"SCSSYSTEMID", SYI$_SCSSYSTEMID, LONG, 4},
 {"SCSSYSTEMIDH", SYI$_SCSSYSTEMIDH, LONG, 4},
 {"SCS_EXISTS", SYI$_SCS_EXISTS, BOOL, 4},
 {"SD_ALLOCLASS", SYI$_SD_ALLOCLASS, LONG, 4},
 {"SECURITY_POLICY", SYI$_SECURITY_POLICY, LONG, 4},
 {"SERIAL_NUMBER", SYI$_SERIAL_NUMBER, BYTE, 16},
 {"SERVED_IO", SYI$_SERVED_IO, LONG, 4},
 {"SETTIME", SYI$_SETTIME, BOOL, 4},
 {"SHADOWING", SYI$_SHADOWING, LONG, 4},
 {"SHADOW_ENABLE", SYI$_SHADOW_ENABLE, LONG, 4},
 {"SHADOW_MAX_COPY", SYI$_SHADOW_MAX_COPY, LONG, 4},
 {"SHADOW_MAX_UNIT", SYI$_SHADOW_MAX_UNIT, LONG, 4},
 {"SHADOW_MBR_TMO", SYI$_SHADOW_MBR_TMO, LONG, 4},
 {"SHADOW_SYS_DISK", SYI$_SHADOW_SYS_DISK, LONG, 4},
 {"SHADOW_SYS_TMO", SYI$_SHADOW_SYS_TMO, LONG, 4},
 {"SHADOW_SYS_UNIT", SYI$_SHADOW_SYS_UNIT, LONG, 4},
 {"SHADOW_SYS_WAIT", SYI$_SHADOW_SYS_WAIT, LONG, 4},
 {"SHARED_VA_PTES", SYI$_SHARED_VA_PTES, BYTE, 8},
 {"SID", SYI$_SID, LONG, 4},
 {"SMCI_FLAGS", SYI$_SMCI_FLAGS, LONG, 4},
 {"SMCI_PORTS", SYI$_SMCI_PORTS, LONG, 4},
 {"SMP_CPUS", SYI$_SMP_CPUS, LONG, 4},
 {"SMP_CPUSH", SYI$_SMP_CPUSH, LONG, 4},
 {"SMP_LNGSPINWAIT", SYI$_SMP_LNGSPINWAIT, LONG, 4},
 {"SMP_SANITY_CNT", SYI$_SMP_SANITY_CNT, LONG, 4},
 {"SMP_SPINWAIT", SYI$_SMP_SPINWAIT, LONG, 4},
 {"SMP_TICK_CNT", SYI$_SMP_TICK_CNT, LONG, 4},
 {"SPTREQ", SYI$_SPTREQ, LONG, 4},
 {"SRPCOUNT", SYI$_SRPCOUNT, LONG, 4},
 {"SRPCOUNTV", SYI$_SRPCOUNTV, LONG, 4},
 {"SRPMIN", SYI$_SRPMIN, LONG, 4},
 {"SRPSIZE", SYI$_SRPSIZE, LONG, 4},
 {"SSINHIBIT", SYI$_SSINHIBIT, BOOL, 4},
 {"STARTUP_P1", SYI$_STARTUP_P1, TEXT, 4},
 {"STARTUP_P2", SYI$_STARTUP_P2, TEXT, 4},
 {"STARTUP_P3", SYI$_STARTUP_P3, TEXT, 4},
 {"STARTUP_P4", SYI$_STARTUP_P4, TEXT, 4},
 {"STARTUP_P5", SYI$_STARTUP_P5, TEXT, 4},
 {"STARTUP_P6", SYI$_STARTUP_P6, TEXT, 4},
 {"STARTUP_P7", SYI$_STARTUP_P7, TEXT, 4},
 {"STARTUP_P8", SYI$_STARTUP_P8, TEXT, 4},
 {"SWAPFILE_FREE", SYI$_SWAPFILE_FREE, LONG, 4},
 {"SWAPFILE_PAGE", SYI$_SWAPFILE_PAGE, LONG, 4},
 {"SWPALLOCINC", SYI$_SWPALLOCINC, LONG, 4},
 {"SWPFAIL", SYI$_SWPFAIL, LONG, 4},
 {"SWPFILCNT", SYI$_SWPFILCNT, LONG, 4},
 {"SWPOUTPGCNT", SYI$_SWPOUTPGCNT, LONG, 4},
 {"SWPRATE", SYI$_SWPRATE, LONG, 4},
 {"SWP_PRIO", SYI$_SWP_PRIO, LONG, 4},
 {"SYSMWCNT", SYI$_SYSMWCNT, LONG, 4},
 {"SYSPFC", SYI$_SYSPFC, LONG, 4},
 {"SYSTEM_CHECK", SYI$_SYSTEM_CHECK, LONG, 4},
 {"SYSTEM_RIGHTS", SYI$_SYSTEM_RIGHTS, RLST, 8},
 {"SYSTYPE", SYI$_SYSTYPE, LONG, 4},
 {"TAILORED", SYI$_TAILORED, LONG, 4},
 {"TAPE_ALLOCLASS", SYI$_TAPE_ALLOCLASS, LONG, 4},
 {"TAPE_MVTIMEOUT", SYI$_TAPE_MVTIMEOUT, LONG, 4},
 {"TBSKIPWSL", SYI$_TBSKIPWSL, LONG, 4},
 {"TEMPERATURE_VECTOR", SYI$_TEMPERATURE_VECTOR, BYTE, 16},
 {"THERMAL_VECTOR", SYI$_THERMAL_VECTOR, BYTE, 16},
 {"TIMEPROMPTWAIT", SYI$_TIMEPROMPTWAIT, LONG, 4},
 {"TIME_CONTROL", SYI$_TIME_CONTROL, LONG, 4},
 {"TIMVCFAIL", SYI$_TIMVCFAIL, LONG, 4},
 {"TMSCP_LOAD", SYI$_TMSCP_LOAD, LONG, 4},
 {"TMSCP_SERVE_ALL", SYI$_TMSCP_SERVE_ALL, LONG, 4},
 {"TTY_ALTALARM", SYI$_TTY_ALTALARM, LONG, 4},
 {"TTY_ALTYPAHD", SYI$_TTY_ALTYPAHD, LONG, 4},
 {"TTY_AUTOCHAR", SYI$_TTY_AUTOCHAR, LONG, 4},
 {"TTY_BUF", SYI$_TTY_BUF, LONG, 4},
 {"TTY_CLASSNAME", SYI$_TTY_CLASSNAME, TEXT, 2},
 {"TTY_DEFCHAR", SYI$_TTY_DEFCHAR, LONG, 4},
 {"TTY_DEFCHAR2", SYI$_TTY_DEFCHAR2, LONG, 4},
 {"TTY_DEFPORT", SYI$_TTY_DEFPORT, LONG, 4},
 {"TTY_DIALTYPE", SYI$_TTY_DIALTYPE, LONG, 4},
 {"TTY_DMASIZE", SYI$_TTY_DMASIZE, LONG, 4},
 {"TTY_OWNER", SYI$_TTY_OWNER, LONG, 4},
 {"TTY_PARITY", SYI$_TTY_PARITY, LONG, 4},
 {"TTY_PROT", SYI$_TTY_PROT, LONG, 4},
 {"TTY_RSPEED", SYI$_TTY_RSPEED, LONG, 4},
 {"TTY_SCANDELTA", SYI$_TTY_SCANDELTA, LONG, 4},
 {"TTY_SILOTIME", SYI$_TTY_SILOTIME, LONG, 4},
 {"TTY_SPEED", SYI$_TTY_SPEED, LONG, 4},
 {"TTY_TIMEOUT", SYI$_TTY_TIMEOUT, LONG, 4},
 {"TTY_TYPAHDSZ", SYI$_TTY_TYPAHDSZ, LONG, 4},
 {"UAFALTERNATE", SYI$_UAFALTERNATE, BOOL, 4},
 {"UDABURSTRATE", SYI$_UDABURSTRATE, LONG, 4},
 {"USED_GBLPAGCNT", SYI$_USED_GBLPAGCNT, LONG, 4},
 {"USED_GBLPAGMAX", SYI$_USED_GBLPAGMAX, LONG, 4},
 {"USED_GBLSECTCNT", SYI$_USED_GBLSECTCNT, LONG, 4},
 {"USED_GBLSECTMAX", SYI$_USED_GBLSECTMAX, LONG, 4},
 {"USER3", SYI$_USER3, LONG, 4},
 {"USER4", SYI$_USER4, LONG, 4},
 {"USERD1", SYI$_USERD1, LONG, 4},
 {"USERD2", SYI$_USERD2, LONG, 4},
 {"VAXCLUSTER", SYI$_VAXCLUSTER, LONG, 4},
 {"VCC_FLAGS", SYI$_VCC_FLAGS, LONG, 4},
 {"VCC_MAXSIZE", SYI$_VCC_MAXSIZE, LONG, 4},
 {"VCC_MAX_CACHE", SYI$_VCC_MAX_CACHE, LONG, 4},
 {"VCC_MAX_IO_SIZE", SYI$_VCC_MAX_IO_SIZE, LONG, 4},
 {"VCC_MAX_LOCKS", SYI$_VCC_MAX_LOCKS, LONG, 4},
 {"VCC_READAHEAD", SYI$_VCC_READAHEAD, LONG, 4},
 {"VCC_WRITEBEHIND", SYI$_VCC_WRITEBEHIND, LONG, 4},
 {"VCC_WRITE_DELAY", SYI$_VCC_WRITE_DELAY, LONG, 4},
 {"VECTOR_EMULATOR", SYI$_VECTOR_EMULATOR, LONG, 4},
 {"VECTOR_MARGIN", SYI$_VECTOR_MARGIN, LONG, 4},
 {"VECTOR_PROC", SYI$_VECTOR_PROC, LONG, 4},
 {"VERSION", SYI$_VERSION, TEXT, 8},
 {"VIRTUALPAGECNT", SYI$_VIRTUALPAGECNT, LONG, 4},
 {"VMS5", SYI$_VMS5, LONG, 4},
 {"VMS6", SYI$_VMS6, LONG, 4},
 {"VMS7", SYI$_VMS7, LONG, 4},
 {"VMS8", SYI$_VMS8, LONG, 4},
 {"VMSD1", SYI$_VMSD1, LONG, 4},
 {"VMSD2", SYI$_VMSD2, LONG, 4},
 {"VMSD3", SYI$_VMSD3, LONG, 4},
 {"VMSD4", SYI$_VMSD4, LONG, 4},
 {"VOTES", SYI$_VOTES, LONG, 4},
 {"VP_MASK", SYI$_VP_MASK, LONG, 4},
 {"VP_NUMBER", SYI$_VP_NUMBER, LONG, 4},
 {"WBM_MSG_INT", SYI$_WBM_MSG_INT, LONG, 4},
 {"WBM_MSG_LOWER", SYI$_WBM_MSG_LOWER, LONG, 4},
 {"WBM_MSG_UPPER", SYI$_WBM_MSG_UPPER, LONG, 4},
 {"WBM_OPCOM_LVL", SYI$_WBM_OPCOM_LVL, LONG, 4},
 {"WINDOW_SYSTEM", SYI$_WINDOW_SYSTEM, LONG, 4},
 {"WLKSYSDSK", SYI$_WLKSYSDSK, BOOL, 4},
 {"WPRE_SIZE", SYI$_WPRE_SIZE, LONG, 4},
 {"WPTTE_SIZE", SYI$_WPTTE_SIZE, LONG, 4},
 {"WRITABLESYS", SYI$_WRITABLESYS, BOOL, 4},
 {"WRITESYSPARAMS", SYI$_WRITESYSPARAMS, BOOL, 4},
 {"WSDEC", SYI$_WSDEC, LONG, 4},
 {"WSDEC_SYS", SYI$_WSDEC_SYS, LONG, 4},
 {"WSINC", SYI$_WSINC, LONG, 4},
 {"WSINC_SYS", SYI$_WSINC_SYS, LONG, 4},
 {"WSMAX", SYI$_WSMAX, LONG, 4},
 {"WS_OPA0", SYI$_WS_OPA0, BOOL, 4},
 {"XCPU", SYI$_XCPU, LONG, 4},
 {"XFMAXRATE", SYI$_XFMAXRATE, LONG, 4},
 {"XQPCTL2", SYI$_XQPCTL2, LONG, 4},
 {"XQPCTL4", SYI$_XQPCTL4, LONG, 4},
 {"XQPCTL6", SYI$_XQPCTL6, LONG, 4},
 {"XQPCTL8", SYI$_XQPCTL8, LONG, 4},
 {"XQPCTLD1", SYI$_XQPCTLD1, LONG, 4},
 {"XQPCTLD3", SYI$_XQPCTLD3, LONG, 4},
 {"XQPCTLD5", SYI$_XQPCTLD5, LONG, 4},
 {"XQPCTLD7", SYI$_XQPCTLD7, LONG, 4},
 {"XQP_ALLOC_BLKS", SYI$_XQP_ALLOC_BLKS, LONG, 4},
 {"XSID", SYI$_XSID, LONG, 4},
 {"ZERO_LIST_HI", SYI$_ZERO_LIST_HI, LONG, 4},
 {"", 0, 0, 0}};

static void  FormatItemData (zval *, struct item_code *, char *, int);
static int   GetRightsSize (char *, struct dsc$descriptor *, unsigned int);
static int   GetMaxCpus (struct dsc$descriptor *, unsigned int);
static int   GetMaxRads (struct dsc$descriptor *, unsigned int);
static char *GetRightsList (unsigned int *, int);
static char *GetDateTime (__int64 *);
static char *BinToHex (char *, int);
static char *GetPrivs (PRVDEF *);
static char *GetIdent (unsigned int);
static int   ParseBits(unsigned long *result, const char *bits_str, struct item_code *codes, int codes_len);
static int   FindToken(const char *source, const char **end, const char *delim, const char** tokens, int length, int stride);
static int   ParseAcmode(const char* acmode_str);

extern int decc$$translate ();
extern EXE$GL_ABSTIM;

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_cvt_filename, 0, 2, MAY_BE_STRING|MAY_BE_LONG|MAY_BE_BOOL|MAY_BE_NULL)
    ZEND_ARG_TYPE_MASK(0, func_code, MAY_BE_LONG|MAY_BE_STRING, NULL)
	ZEND_ARG_TYPE_INFO(0, file_name, IS_STRING, 0)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_getdvi, 0, 1, MAY_BE_STRING|MAY_BE_LONG|MAY_BE_BOOL|MAY_BE_NULL)
	ZEND_ARG_TYPE_MASK(0, item_code, MAY_BE_LONG|MAY_BE_STRING, NULL)
	ZEND_ARG_TYPE_INFO(0, device_name, IS_STRING, 1)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_getjpi, 0, 1, MAY_BE_STRING|MAY_BE_LONG|MAY_BE_BOOL|MAY_BE_NULL)
	ZEND_ARG_TYPE_MASK(0, item_code, MAY_BE_LONG|MAY_BE_STRING, NULL)
	ZEND_ARG_TYPE_INFO(0, proc_name, IS_STRING, 1)
    ZEND_ARG_TYPE_MASK(1, pid, MAY_BE_LONG|MAY_BE_STRING|MAY_BE_NULL, NULL)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_getsyi, 0, 1,  MAY_BE_STRING|MAY_BE_LONG|MAY_BE_BOOL|MAY_BE_NULL)
	ZEND_ARG_TYPE_MASK(0, item_code, MAY_BE_LONG|MAY_BE_STRING, NULL)
	ZEND_ARG_TYPE_INFO(0, node_name, IS_STRING, 1)
	ZEND_ARG_TYPE_MASK(1, csid, MAY_BE_LONG|MAY_BE_STRING|MAY_BE_NULL, NULL)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_time, 0, 0, MAY_BE_STRING|MAY_BE_LONG|MAY_BE_BOOL|MAY_BE_NULL)
    ZEND_ARG_TYPE_MASK(0, time, MAY_BE_LONG|MAY_BE_STRING|MAY_BE_NULL, NULL)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_uptime, 0, 0, MAY_BE_STRING|MAY_BE_LONG|MAY_BE_BOOL|MAY_BE_NULL)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_message, 0, 1, MAY_BE_STRING|MAY_BE_LONG|MAY_BE_BOOL|MAY_BE_NULL)
    ZEND_ARG_TYPE_MASK(0, status_code, MAY_BE_LONG|MAY_BE_STRING, NULL)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_status, 0, 0, MAY_BE_STRING|MAY_BE_LONG|MAY_BE_BOOL|MAY_BE_NULL)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_trnlnm, 0, 0,  MAY_BE_STRING|MAY_BE_LONG|MAY_BE_BOOL|MAY_BE_NULL)
    ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, attr, IS_STRING, 1, "NULL")
    ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, tabnam, IS_STRING, 1, "NULL")
	ZEND_ARG_TYPE_INFO(0, lognam, IS_STRING, 0)
	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, acmode, IS_STRING, 1, "NULL")
	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, itmlst, IS_ARRAY, 1, "NULL")
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_dellnm, 0, 1, MAY_BE_BOOL)
    ZEND_ARG_TYPE_INFO(0, tabnam, IS_STRING, 0)
	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, lognam, IS_STRING, 1, "NULL")
	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, acmode, IS_STRING, 1, "NULL")
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_symbol_set, 0, 2, MAY_BE_BOOL)
    ZEND_ARG_TYPE_INFO(0, symbol_name, IS_STRING, 0)
    ZEND_ARG_TYPE_INFO(0, symbol_value, IS_STRING, 0)
	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, true_if_global, _IS_BOOL, 1, "false")
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_openvms_symbol_get, 0, 1, MAY_BE_STRING|MAY_BE_BOOL)
    ZEND_ARG_TYPE_INFO(0, symbol_name, IS_STRING, 0)
    ZEND_ARG_TYPE_MASK(0, true_if_global, MAY_BE_BOOL|MAY_BE_NULL, NULL)
	//ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, true_if_global, _IS_BOOL, 1, "null")
ZEND_END_ARG_INFO()

const zend_function_entry openvms_functions[] = {
 PHP_FE(openvms_cvt_filename, arginfo_openvms_cvt_filename)
 PHP_FE(openvms_getdvi, arginfo_openvms_getdvi)
 PHP_FE(openvms_getjpi, arginfo_openvms_getjpi)
 PHP_FE(openvms_getsyi, arginfo_openvms_getsyi)
 PHP_FE(openvms_message, arginfo_openvms_message)
 PHP_FE(openvms_status, arginfo_openvms_status)
 PHP_FE(openvms_time, arginfo_openvms_time)
 PHP_FE(openvms_uptime, arginfo_openvms_uptime)
 PHP_FE(openvms_trnlnm, arginfo_openvms_trnlnm) 
 PHP_FE(openvms_crelnm, arginfo_openvms_trnlnm) 
 PHP_FE(openvms_dellnm, arginfo_openvms_dellnm) 
 PHP_FE(openvms_symbol_set, arginfo_openvms_symbol_set) 
 PHP_FE(openvms_symbol_get, arginfo_openvms_symbol_get) 
 PHP_FE(openvms_symbol_delete, arginfo_openvms_symbol_get) 
 PHP_FE_END
};

zend_module_entry openvms_module_entry = {
 STANDARD_MODULE_HEADER,
 "openvms",
 openvms_functions,
 PHP_MINIT(openvms),
 NULL,
 PHP_RINIT(openvms),
 NULL,
 PHP_MINFO(openvms),
 NO_VERSION_YET,
 STANDARD_MODULE_PROPERTIES,
};

#ifdef COMPILE_DL_OPENVMS
ZEND_GET_MODULE(openvms)
#endif

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_MINIT_FUNCTION(openvms)
{

/*
** Define the conversion constants
*/
REGISTER_LONG_CONSTANT ("OPENVMS_CVT_VMS_TO_UNIX",
			 OPENVMS_CVT_VMS_TO_UNIX, CONST_CS|CONST_PERSISTENT);
REGISTER_LONG_CONSTANT ("OPENVMS_CVT_UNIX_TO_VMS",
			 OPENVMS_CVT_UNIX_TO_VMS, CONST_CS|CONST_PERSISTENT);

return SUCCESS;

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_RINIT_FUNCTION(openvms)
{

/*
** Initialize the status
*/
decc$$translate (SS$_NORMAL);

return SUCCESS;

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_MINFO_FUNCTION(openvms)
{
char Version[32];


if (OPENVMS_UPD_VER)
    sprintf (Version, "%d.%d-%d", OPENVMS_MAJ_VER, OPENVMS_MIN_VER, OPENVMS_UPD_VER);
else
    sprintf (Version, "%d.%d", OPENVMS_MAJ_VER, OPENVMS_MIN_VER);

php_info_print_table_start ();
php_info_print_table_row (2, "OpenVMS API support", "Enabled");
php_info_print_table_row (2, "Version ", Version);
php_info_print_table_end ();

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_cvt_filename)
{
char *CvtFile = NULL,
     *RetFile = NULL;
char *filename_ptr;
int filename_len;
long cvt_type;
int status;


/*
** Establish a normal status
*/
decc$$translate (SS$_NORMAL);

/*
** Parse the given aguments
*/
if (zend_parse_parameters (ZEND_NUM_ARGS() TSRMLS_CC, "ls", &cvt_type, &filename_ptr, &filename_len) == FAILURE)
    RETURN_FALSE;

/*
** Process the requested conversion
*/
switch (cvt_type)
    {
    case OPENVMS_CVT_VMS_TO_UNIX:
	status = apl_ConvertFnm (CVT_FNM_VMS_TO_UNIX, filename_ptr, &CvtFile);
	break;

    case OPENVMS_CVT_UNIX_TO_VMS:
	status = apl_ConvertFnm (CVT_FNM_UNIX_TO_VMS, filename_ptr, &CvtFile);
	break;

    default:
	php_error_docref (NULL TSRMLS_CC, E_WARNING,
		          "Invalid conversion type value %d specified", cvt_type);
	RETURN_FALSE;
	break;
    }

/*
** If the convertion was successful, then return the converted filename, otherwise return FALSE
*/
if (status && CvtFile)
    {
    RetFile = estrdup (CvtFile);
    free (CvtFile);
    RETURN_STRING (RetFile);
    }
else
    {
    decc$$translate (SS$_NOSUCHPATH);
    if (CvtFile)
	free (CvtFile);
    RETURN_FALSE;
    }

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_getdvi)
{
struct dsc$descriptor DviDevDesc = { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0 };
static char *DviItemBuf = NULL;
static int DviItemMax = 0;
char *DviItemPtr,
     *DviDevPtr = NULL;
int DviItemIdx = -1,
    DviItemLen,
    DviDevLen = 0,
    status, i;
ILE3 DviItems[2];
ILE3 *Ile3Ptr;
IOSB iosb;


/*
** Establish a normal status
*/
decc$$translate (SS$_NORMAL);

/*
** Parse the given aguments
*/
if (zend_parse_parameters (ZEND_NUM_ARGS() TSRMLS_CC, "s|s",
			   &DviItemPtr, &DviItemLen, &DviDevPtr, &DviDevLen) == FAILURE)
    {
    decc$$translate (SS$_BADPARAM);
    RETURN_FALSE;
    }

/*
** Check to see if the user is asking for the list of supported items
*/
if (strcasecmp (DviItemPtr, "?") == 0)
    {
    char DviIdxBuf[32+1];

    /*
    ** Load the supported items into the return array
    */
    array_init (return_value);
    for (i = 0; strlen (dvi_items[i].item_name); i++)
	{
	sprintf (DviIdxBuf, "%d", i);
	add_assoc_stringl (return_value, DviIdxBuf, dvi_items[i].item_name, 1);
	}

    return;
    }

/*
** Validate and set the given JPI item
*/
for (i = 0; strlen (dvi_items[i].item_name); i++)
    if (strcasecmp (DviItemPtr, dvi_items[i].item_name) == 0)
	{
	DviItemIdx = i;
	break;
	}
if (DviItemIdx < 0)
    {
    php_error_docref (NULL TSRMLS_CC, E_WARNING,
    		      "Invalid item code %s specified", DviItemPtr);
    decc$$translate (SS$_BADITMCOD);
    RETURN_FALSE;
    }

/*
** Allocate the item buffer
*/
if (DviItemBuf == NULL)
    {
    for (i = 0; strlen (dvi_items[i].item_name); i++)
	DviItemMax = MAX (DviItemMax, dvi_items[i].item_size);
    DviItemBuf = malloc (DviItemMax + 1);
    }
DviItemLen = 0;

/*
** Process the node name if given
*/
if (DviDevPtr && DviDevLen)
    {
    DviDevDesc.dsc$w_length = DviDevLen;
    DviDevDesc.dsc$a_pointer = DviDevPtr;
    }
else
    {
    DviDevDesc.dsc$w_length = 2;
    DviDevDesc.dsc$a_pointer = "TT";
    }

/*
** Setup the DVI item list
*/
ILE3_INIT (DviItems);
ILE3_ADD  (dvi_items[DviItemIdx].item_code, dvi_items[DviItemIdx].item_size, DviItemBuf, &DviItemLen);
ILE3_TERM;

/*
** Get the DVI information
*/
status = SYS$GETDVIW (EFN$C_ENF,		/* No event flag              */
                      0,			/* No device channel	      */
                      &DviDevDesc,		/* Device name descriptor     */
                      &DviItems,		/* Item list                  */
                      &iosb,			/* IOSB                       */
                      0,			/* No AST routine             */
                      0,			/* No AST parameter           */
                      0);			/* Null argument	      */
if (status & 1)
    status = iosb.iosb$w_status;
if (! (status & 1))
    {
    php_error_docref (NULL TSRMLS_CC, E_WARNING,
		      "Unable to retrieve %s (%08X)", DviItemPtr, status);
    decc$$translate (status);
    RETURN_FALSE;
    }

/*
** Format the return value
*/
FormatItemData (return_value, &dvi_items[DviItemIdx], DviItemBuf, DviItemLen);

return;

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_getjpi)
{
struct dsc$descriptor JpiProcDesc = { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0 };
struct dsc$descriptor *JpiProcDescPtr = NULL;
static char *JpiItemBuf = NULL;
unsigned int JpiPidVal = 0;
static int JpiItemMax = 0;
zval *JpiPidPtr = NULL;
zval *JpiPidPtrRef = NULL;
char *JpiItemPtr,
     *JpiProcPtr = NULL;
int JpiItemIdx = -1,
    JpiItemLen,
    JpiProcLen = 0,
    status, i;
ILE3 JpiItems[2];
ILE3 *Ile3Ptr;
IOSB iosb;


/*
** Establish a normal status
*/
decc$$translate (SS$_NORMAL);

/*
** Parse the given aguments
*/
if (zend_parse_parameters (ZEND_NUM_ARGS() TSRMLS_CC, "s|sz",
			   &JpiItemPtr, &JpiItemLen, &JpiProcPtr, &JpiProcLen, &JpiPidPtrRef) == FAILURE)
    RETURN_FALSE;

if (JpiPidPtrRef) {
    ZEND_ASSERT(Z_ISREF_P(JpiPidPtrRef));
    JpiPidPtr = Z_REFVAL_P(JpiPidPtrRef);
}

/*
** Check to see if the user is asking for the list of supported items
*/
if (strcasecmp (JpiItemPtr, "?") == 0)
    {
    char JpiIdxBuf[32+1];

    /*
    ** Load the supported items into the return array
    */
    array_init (return_value);
    for (i = 0; strlen (jpi_items[i].item_name); i++)
	{
	sprintf (JpiIdxBuf, "%d", i);
	add_assoc_stringl (return_value, JpiIdxBuf, jpi_items[i].item_name, 1);
	}

    return;
    }

/*
** Validate and set the given JPI item
*/
for (i = 0; strlen (jpi_items[i].item_name); i++)
    if (strcasecmp (JpiItemPtr, jpi_items[i].item_name) == 0)
	{
	JpiItemIdx = i;
	break;
	}
if (JpiItemIdx < 0)
    {
    php_error_docref (NULL TSRMLS_CC, E_WARNING,
    		      "Invalid item code %s specified", JpiItemPtr);
    RETURN_FALSE;
    }

/*
** Allocate the item buffer
*/
if (JpiItemBuf == NULL)
    {
    for (i = 0; strlen (jpi_items[i].item_name); i++)
	JpiItemMax = MAX (JpiItemMax, jpi_items[i].item_size);
    JpiItemBuf = malloc (JpiItemMax + 1);
    }
JpiItemLen = 0;

/*
** Process the node name if given
*/
if (JpiProcPtr && JpiProcLen)
    {
    JpiProcDescPtr = &JpiProcDesc;
    JpiProcDesc.dsc$w_length = JpiProcLen;
    JpiProcDesc.dsc$a_pointer = JpiProcPtr;
    }

/*
** Get the Pid value if it's provided
*/
if (JpiPidPtr != NULL)
    {
    if (Z_TYPE_P (JpiPidPtr) == IS_STRING)
	{
	status = LIB$CVT_HTB (Z_STRLEN_P (JpiPidPtr), Z_STRVAL_P (JpiPidPtr), (int *) &JpiPidVal);
	if (! (status & 1))
	    {
	    php_error_docref (NULL TSRMLS_CC, E_WARNING,
		              "Unable to convert PID '%s' to binary (%08X)", Z_STRVAL_P (JpiPidPtr), status);
	    decc$$translate (status);
	    RETURN_FALSE;
	    }
	}
    else
	{
	if (Z_TYPE_P (JpiPidPtr) != IS_LONG)
	    {
	    zval_copy_ctor (JpiPidPtr);
	    convert_to_long (JpiPidPtr);
	    }
	JpiPidVal = Z_LVAL_P (JpiPidPtr);
	}
    }

/*
** If the item code is a rights list, then we'll need to get
** the size of the rights list
*/
if (jpi_items[JpiItemIdx].item_type == RLST)
    {
    /*
    ** Update this rights list item size
    */
    jpi_items[JpiItemIdx].item_size = GetRightsSize (JpiItemPtr, JpiProcDescPtr, JpiPidVal);

    /*
    ** Check to see if we need to adjust the size of the item buffer
    */
    if (jpi_items[JpiItemIdx].item_size > JpiItemMax)
	{
	JpiItemMax = jpi_items[JpiItemIdx].item_size;
	free (JpiItemBuf);
	JpiItemBuf = malloc (JpiItemMax + 1);
	}
    }

/*
** Setup the JPI item list
*/
ILE3_INIT (JpiItems);
ILE3_ADD  (jpi_items[JpiItemIdx].item_code, jpi_items[JpiItemIdx].item_size, JpiItemBuf, &JpiItemLen);
ILE3_TERM;

/*
** Get the JPI information
*/
status = SYS$GETJPIW (EFN$C_ENF,		/* No event flag              */
                      &JpiPidVal, 		/* PID address                */
                      JpiProcDescPtr,		/* Process name descriptor    */
                      &JpiItems,		/* Item list                  */
                      &iosb,			/* IOSB                       */
                      0,			/* No AST routine             */
                      0);			/* No AST parameter           */
if (status & 1)
    status = iosb.iosb$w_status;
if (! (status & 1))
    {
    if (! (status == SS$_NOMOREPROC && JpiPidPtr != NULL))
	php_error_docref (NULL TSRMLS_CC, E_WARNING,
		          "Unable to retrieve %s (%08X)", JpiItemPtr, status);
    decc$$translate (status);
    RETURN_FALSE;
    }

/*
** Return the Pid value just in case it's a context value
*/
if (JpiPidPtr != NULL)
    {
    ZVAL_LONG (JpiPidPtr, JpiPidVal);
    }

/*
** Format the return value
*/
FormatItemData (return_value, &jpi_items[JpiItemIdx], JpiItemBuf, JpiItemLen);

return;

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_getsyi)
{
struct dsc$descriptor SyiNodeDesc = { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0 };
struct dsc$descriptor *SyiNodeDescPtr = NULL;
static char *SyiItemBuf = NULL;
unsigned int SyiCsidVal = 0;
static int SyiItemMax = 0;
zval *SyiCsidPtr = NULL;
zval *SyiCsidPtrRef = NULL;
char *SyiItemPtr,
     *SyiNodePtr = NULL;
int SyiItemIdx = -1,
    SyiItemLen,
    SyiNodeLen = 0,
    status, i;
ILE3 SyiItems[2];
ILE3 *Ile3Ptr;
IOSB iosb;


/*
** Establish a normal status
*/
decc$$translate (SS$_NORMAL);

/*
** Parse the given aguments
*/
if (zend_parse_parameters (ZEND_NUM_ARGS() TSRMLS_CC, "s|sz",
			   &SyiItemPtr, &SyiItemLen, &SyiNodePtr, &SyiNodeLen, &SyiCsidPtrRef) == FAILURE)
    RETURN_FALSE;

if (SyiCsidPtrRef) {
    ZEND_ASSERT(Z_ISREF_P(SyiCsidPtrRef));
    SyiCsidPtr = Z_REFVAL_P(SyiCsidPtrRef);
}

/*
** Check to see if the user is asking for the list of supported items
*/
if (strcasecmp (SyiItemPtr, "?") == 0)
    {
    char SyiIdxBuf[32+1];

    /*
    ** Load the supported items into the return array
    */
    array_init (return_value);
    for (i = 0; strlen (syi_items[i].item_name); i++)
	{
	sprintf (SyiIdxBuf, "%d", i);
	add_assoc_stringl (return_value, SyiIdxBuf, syi_items[i].item_name, 1);
	}
    return;
    }

/*
** Validate and set the given SYI item
*/
for (i = 0; strlen (syi_items[i].item_name); i++)
    if (strcasecmp (SyiItemPtr, syi_items[i].item_name) == 0)
	{
	SyiItemIdx = i;
	break;
	}
if (SyiItemIdx < 0)
    {
    php_error_docref (NULL TSRMLS_CC, E_WARNING,
    		      "Invalid item code %s specified", SyiItemPtr);
    RETURN_FALSE;
    }

/*
** Allocate the item buffer
*/
if (SyiItemBuf == NULL)
    {
    for (i = 0; strlen (syi_items[i].item_name); i++)
	SyiItemMax = MAX (SyiItemMax, syi_items[i].item_size);
    SyiItemBuf = malloc (SyiItemMax + 1);
    }
SyiItemLen = 0;

/*
** Process the node name if given
*/
if (SyiNodePtr && SyiNodeLen)
    {
    SyiNodeDescPtr = &SyiNodeDesc;
    SyiNodeDesc.dsc$w_length = SyiNodeLen;
    SyiNodeDesc.dsc$a_pointer = SyiNodePtr;
    }

/*
** Get the Csid value if it's provided
*/
if (SyiCsidPtr != NULL)
    {
    if (Z_TYPE_P (SyiCsidPtr) == IS_STRING)
	{
	status = LIB$CVT_HTB (Z_STRLEN_P (SyiCsidPtr), Z_STRVAL_P (SyiCsidPtr), (int *) &SyiCsidVal);
	if (! (status & 1))
	    {
	    php_error_docref (NULL TSRMLS_CC, E_WARNING,
		              "Unable to convert CSID '%s' to binary (%08X)", Z_STRVAL_P (SyiCsidPtr), status);
	    decc$$translate (status);
	    RETURN_FALSE;
	    }
	}
    else
	{
	if (Z_TYPE_P (SyiCsidPtr) != IS_LONG)
	    {
	    zval_copy_ctor (SyiCsidPtr);
	    convert_to_long (SyiCsidPtr);
	    }
	SyiCsidVal = Z_LVAL_P (SyiCsidPtr);
	}
    }

/*
** If the item code is a rights list, then we'll need to get
** the size of the rights list
*/
if (syi_items[SyiItemIdx].item_type == RLST)
    {
    /*
    ** Update this rights list item size
    */
    syi_items[SyiItemIdx].item_size = GetRightsSize (SyiItemPtr, NULL, 0);

    /*
    ** Check to see if we need to adjust the size of the item buffer
    */
    if (syi_items[SyiItemIdx].item_size > SyiItemMax)
	{
	SyiItemMax = syi_items[SyiItemIdx].item_size;
	free (SyiItemBuf);
	SyiItemBuf = malloc (SyiItemMax + 1);
	}
    }

/*
** If the item code is a cpu type item, then we'll need to get the number of
** CPUs and calculate the new size of the cpu array
*/
if (strcasecmp (syi_items[SyiItemIdx].item_name, "CPUCAP_MASK") == 0 ||
    strcasecmp (syi_items[SyiItemIdx].item_name, "CPU_AUTOSTART") == 0 ||
    strcasecmp (syi_items[SyiItemIdx].item_name, "CPU_FAILOVER") == 0)
    {
    /*
    ** Update this cpu type item size
    */
    syi_items[SyiItemIdx].item_size = syi_items[SyiItemIdx].item_size * GetMaxCpus (SyiNodeDescPtr, SyiCsidVal);

    /*
    ** Check to see if we need to adjust the size of the item buffer
    */
    if (syi_items[SyiItemIdx].item_size > SyiItemMax)
	{
	SyiItemMax = syi_items[SyiItemIdx].item_size;
	free (SyiItemBuf);
	SyiItemBuf = malloc (SyiItemMax + 1);
	}
    }

/*
** If the item code is a rad type item, then we'll need to get the number of
** RADs and calculate the new size of the rad array
*/
if (strcasecmp (syi_items[SyiItemIdx].item_name, "RAD_CPUS") == 0 ||
    strcasecmp (syi_items[SyiItemIdx].item_name, "RAD_MEMSIZE") == 0 ||
    strcasecmp (syi_items[SyiItemIdx].item_name, "RAD_SHMEMSIZE") == 0)
    {
    /*
    ** Update this cpu type item size
    */
    syi_items[SyiItemIdx].item_size = syi_items[SyiItemIdx].item_size * GetMaxRads (SyiNodeDescPtr, SyiCsidVal);

    /*
    ** Check to see if we need to adjust the size of the item buffer
    */
    if (syi_items[SyiItemIdx].item_size > SyiItemMax)
	{
	SyiItemMax = syi_items[SyiItemIdx].item_size;
	free (SyiItemBuf);
	SyiItemBuf = malloc (SyiItemMax + 1);
	}
    }

/*
** Setup the SYI item list
*/
ILE3_INIT (SyiItems);
ILE3_ADD  (syi_items[SyiItemIdx].item_code, syi_items[SyiItemIdx].item_size, SyiItemBuf, &SyiItemLen);
ILE3_TERM;

/*
** Get the SYI information
*/
status = SYS$GETSYIW (EFN$C_ENF,		/* No event flag              */
                      &SyiCsidVal, 		/* CSID address               */
                      SyiNodeDescPtr,		/* Node name descriptor       */
                      &SyiItems,		/* Item list                  */
                      &iosb,			/* IOSB                       */
                      0,			/* No AST routine             */
                      0);			/* No AST parameter           */
if (status & 1)
    status = iosb.iosb$w_status;
if (! (status & 1))
    {
    if (! (status == SS$_NOMORENODE && SyiCsidPtr != NULL))
        php_error_docref (NULL TSRMLS_CC, E_WARNING,
		          "Unable to retrieve %s (%08X)", SyiItemPtr, status);
    decc$$translate (status);
    RETURN_FALSE;
    }

/*
** Return the Csid value just in case it's a context value
*/
if (SyiCsidPtr != NULL)
    {
    ZVAL_LONG (SyiCsidPtr, SyiCsidVal);
}

/*
** Format the return value
*/
FormatItemData (return_value, &syi_items[SyiItemIdx], SyiItemBuf, SyiItemLen);

return;

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_message)
{
struct dsc$descriptor MsgDesc = { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0 };
char MsgBuf[MSG_BUF_LEN+1];
zval *StatusPtr = NULL;
int StatusVal = vaxc$errno,
    status;


/*
** Parse the given aguments
*/
if (zend_parse_parameters (ZEND_NUM_ARGS() TSRMLS_CC, "|z", &StatusPtr) == FAILURE)
    RETURN_FALSE;

/*
** Get the status value if it's provided
*/
if (StatusPtr != NULL)
    {
    if (Z_TYPE_P (StatusPtr) == IS_STRING)
	{
	status = LIB$CVT_HTB (Z_STRLEN_P (StatusPtr), Z_STRVAL_P (StatusPtr), (int *) &StatusVal);
	if (! (status & 1))
	    {
	    php_error_docref (NULL TSRMLS_CC, E_WARNING,
		              "Unable to convert status value '%s' to binary (%08X)", Z_STRVAL_P (StatusPtr), status);
	    RETURN_FALSE;
	    }
	}
    else
	{
	if (Z_TYPE_P (StatusPtr) != IS_LONG)
	    {
	    zval_copy_ctor (StatusPtr);
	    convert_to_long (StatusPtr);
	    }
	StatusVal = Z_LVAL_P (StatusPtr);
	}
    }

/*
** Setup the message descriptor
*/
MsgDesc.dsc$a_pointer = MsgBuf;
MsgDesc.dsc$w_length = MSG_BUF_LEN;

/*
** Retrieve the message text
*/
status = SYS$GETMSG (StatusVal,
		     &MsgDesc.dsc$w_length,
		     &MsgDesc,
		     0,
		     0);
if (! (status & 1))
    {
    php_error_docref (NULL TSRMLS_CC, E_WARNING,
		      "Unable to retrieve status message 0x%08X (%08X)", StatusVal, status);
    RETURN_FALSE;
    }
else
    {
    MsgDesc.dsc$a_pointer[MsgDesc.dsc$w_length] = '\0';
    RETURN_STRINGL (MsgDesc.dsc$a_pointer, MsgDesc.dsc$w_length);
    }

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_status)
{

/*
** Verify the correct agument count
*/
if (ZEND_NUM_ARGS() != 0)
    WRONG_PARAM_COUNT;

/*
** return the last OpenVMS status
*/
RETURN_LONG (vaxc$errno);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_time)
{
char DateTimeBuf[DATE_TIME_LEN+1],
    *DateTimePtr;
__int64 BinDateTime = 0;
zval *TimePtr = NULL;
int TimeVal = 0;
int status;


/*
** Establish a normal status
*/
decc$$translate (SS$_NORMAL);

/*
** Parse the given aguments
*/
if (zend_parse_parameters (ZEND_NUM_ARGS() TSRMLS_CC, "|z", &TimePtr) == FAILURE)
    RETURN_FALSE;

/*
** Get the time value if it's provided
*/
if (TimePtr != NULL)
    {
    if (Z_TYPE_P (TimePtr) != IS_LONG)
        {
        zval_copy_ctor (TimePtr);
        convert_to_long (TimePtr);
        }
    TimeVal = Z_LVAL_P (TimePtr);
    }

/*
** Convert the millisecond time to a delta time string, otherwise
** get the current date & time
*/
if (TimePtr != NULL)
    {
    if (TimeVal)
	{
	/*
	** Calculate the delta time
	*/
	status = LIB$EMUL (&TimeVal,
	     		   &-100000,
			   &0,
			   (void *) &BinDateTime);
	if (! (status & 1))
	    {
	    php_error_docref (NULL TSRMLS_CC, E_WARNING,
		              "Unable to calculate time (%08X)", status);
	    decc$$translate (status);
	    RETURN_FALSE;
	    }
	DateTimePtr = GetDateTime (&BinDateTime);
	}
    else
	DateTimePtr = strdup ("   0 00:00:00.00");
    }
else
    DateTimePtr = GetDateTime (0);
if (DateTimePtr)
    strcpy (DateTimeBuf, DateTimePtr);
else
    strcpy (DateTimeBuf, "");

/*
** Free any allocated data
*/
if (DateTimePtr)
    free (DateTimePtr);

/*
** Return the date/time string
*/
RETURN_STRING (DateTimeBuf);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_uptime)
{
char DateTimeBuf[DATE_TIME_LEN+1],
    *DateTimePtr;
unsigned __int64 BinUpTime;
int status;


/*
** Establish a normal status
*/
decc$$translate (SS$_NORMAL);

/*
** Verify the correct agument count
*/
if (ZEND_NUM_ARGS() != 0)
    WRONG_PARAM_COUNT;

/*
** Calculate the system uptime
*/
status = LIB$EMUL (&EXE$GL_ABSTIM,
		   &-10000000,
		   &0,
		   (void *) &BinUpTime);
if (! (status & 1))
    {
    php_error_docref (NULL TSRMLS_CC, E_WARNING,
		      "Unable to calculate system up time (%08X)", status);
    decc$$translate (status);
    RETURN_FALSE;
    }

/*
** Convert the uptime to a string
*/
DateTimePtr = GetDateTime ((__int64 *) &BinUpTime);
if (DateTimePtr)
    strcpy (DateTimeBuf, DateTimePtr);
else
    strcpy (DateTimeBuf, "");

/*
** Free any allocated data
*/
if (DateTimePtr)
    free (DateTimePtr);

/*
** Eliminate the hundreths of seconds
*/
DateTimePtr = strstr (DateTimeBuf, ".");
if (DateTimePtr)
    *DateTimePtr = '\0';

/*
** Return the date/time string
*/
RETURN_STRING (DateTimeBuf);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/

static void OpenVMS_LNM(INTERNAL_FUNCTION_PARAMETERS, int create) {
    int         status = SS$_NORMAL;
    char*       attr_str = NULL;
    size_t      attr_len = 0;
    char*       tabnam_str = NULL;
    size_t      tabnam_len = 0;
    char*       lognam_str = NULL;
    size_t      lognam_len = 0;
    char*       acmode_str = NULL;
    size_t      acmode_len = 0;
    zval*       itmlst = NULL;
    
    decc$$translate (status);

    ZEND_PARSE_PARAMETERS_START(0, 5)
        Z_PARAM_OPTIONAL
        Z_PARAM_STRING_OR_NULL(attr_str, attr_len)
        Z_PARAM_STRING_OR_NULL(tabnam_str, tabnam_len)
        Z_PARAM_STRING(lognam_str, lognam_len)
        Z_PARAM_STRING_OR_NULL(acmode_str, acmode_len)
        Z_PARAM_ZVAL_OR_NULL(itmlst)
    ZEND_PARSE_PARAMETERS_END();

#if 0
    printf("\nOpenVMS_LNM: %s\n", create ? "create" : "translate");
    printf("attr_str: \"%s\", %i\n", attr_str, attr_len);
    printf("tabnam_str: \"%s\", %i\n", tabnam_str, tabnam_len);
    printf("lognam_str: \"%s\", %i\n", lognam_str, lognam_len);
    printf("acmode_str: \"%s\", %i\n", acmode_str, acmode_len);
#endif

    if (!lognam_str || !lognam_len) {
        php_error_docref (NULL TSRMLS_CC, E_WARNING, "logname must not be empty");
        RETURN_FALSE;
    }

    unsigned int attr = 0, *pattr = NULL;
    if (attr_str && attr_len) {
        unsigned long result = 0;
        if (!ParseBits(&result, attr_str, lnm_item_attr, sizeof(lnm_item_attr)/sizeof(lnm_item_attr[0]))) {
            php_error_docref (NULL TSRMLS_CC, E_WARNING, "invalid attr value %s", attr_str);
            RETURN_FALSE;
        }
        attr = (unsigned int)result;
        pattr = &attr;
    }

    char *tabnam = create ? "LNM$PROCESS_TABLE" : "LNM$FILE_DEV";
    size_t tabnam_size = strlen(tabnam);
    if (tabnam_str && tabnam_len) {
        tabnam = tabnam_str;
        tabnam_size = tabnam_len;
    }
    
    unsigned char acmode = PSL$C_USER, *pacmode = NULL;
    if (acmode_str && acmode_len) {
        int i_acmode = ParseAcmode(acmode_str);
        if (i_acmode != -1) {
            acmode = (unsigned char)i_acmode;
            pacmode = &acmode;
        }
    }

    $DESCRIPTOR(tabnam_dsc, "");
    $DESCRIPTOR(lognam_dsc, "");
    __void_ptr32 plognam_dsc = NULL;

    tabnam_dsc.dsc$w_length = tabnam_size;
    set_dsc_string(tabnam_dsc, tabnam);

    if (lognam_str && lognam_len) {
        lognam_dsc.dsc$w_length = lognam_len;
        set_dsc_string(lognam_dsc, lognam_str);
        plognam_dsc = &lognam_dsc;
    }

    unsigned long ile3_codes = 1 << LNM$_STRING;    // assume LNM$_STRING is always set
    long ile3_count = 1;
    struct itmlst_parsed {
        int code;
        int bitmask;
    } *itmlst_parsed = NULL;

    // collect values from array
    unsigned long lnm_index = 0;
    char *lnm_string = NULL;
    unsigned long lnm_attributes = 0;

    if (itmlst) {
        uint32_t itmlst_len = zend_array_count(Z_ARR_P(itmlst));
        itmlst_parsed = (struct itmlst_parsed*)alloca(itmlst_len * sizeof(struct itmlst_parsed));
        memset(itmlst_parsed, 0, itmlst_len * sizeof(struct itmlst_parsed));
        zend_ulong idx;
        zend_string *key;
        zval *val;
        int itmlst_parsed_idx = 0;
        ZEND_HASH_FOREACH_KEY_VAL(Z_ARR_P(itmlst), idx, key, val) {
            if (key) {
                unsigned long result = 0;
                if (ParseBits(&result, ZSTR_VAL(key), lnm_items, sizeof(lnm_items)/sizeof(lnm_items[0]))) {
                    itmlst_parsed[itmlst_parsed_idx].code = result;
                    if (!(ile3_codes & (1 << result))) {
                        ++ile3_count;
                    }
                    ile3_codes |= 1 << result;
                    // special case for LNM$_INDEX, we should get its value
                    if (result == LNM$_INDEX) {
                        if (Z_TYPE_P(val) == IS_LONG) {
                            lnm_index = Z_LVAL_P(val);
                        } else if (Z_TYPE_P(val) == IS_STRING) {
                            lnm_index = atoi(Z_STRVAL_P(val));
                        }
                    } else if (result == LNM$_STRING) {
                        // save only on create
                        if (create && Z_TYPE_P(val) == IS_STRING && Z_STRVAL_P(val)) {
                            int len = strlen(Z_STRVAL_P(val));
                            if (len > 255) {
                                len = 255;
                            }
                            lnm_string = alloca(len + 1);
                            strncpy(lnm_string, Z_STRVAL_P(val), len);
                            lnm_string[len] = 0;
                        }
                    }
                } else if (ParseBits(&result, ZSTR_VAL(key), lnm_item_attr, sizeof(lnm_item_attr)/sizeof(lnm_item_attr[0]))) {
                    itmlst_parsed[itmlst_parsed_idx].code = LNM$_ATTRIBUTES;
                    itmlst_parsed[itmlst_parsed_idx].bitmask = result;
                    lnm_attributes |= result;
                    if (!(ile3_codes & (1 << LNM$_ATTRIBUTES))) {
                        ++ile3_count;
                    }
                    ile3_codes |= 1 << LNM$_ATTRIBUTES;
                } else {
                    itmlst_parsed[itmlst_parsed_idx].code = -1;
                }
                ++itmlst_parsed_idx;
            }
        } ZEND_HASH_FOREACH_END();    
    }

    if (create && !lnm_string) {
        php_error_docref (NULL TSRMLS_CC, E_WARNING, "lognam value must be present in array");
        RETURN_FALSE;
    }

    ILE3 *item_list = alloca((ile3_count + 1) * sizeof(ILE3));
    int ile3_idx = 0;
    memset(item_list, 0, (ile3_count + 1) * sizeof(ILE3));

    // create item list in the same order as lnm_items
    // also, put collected from array values
    for(int i = 0; i < sizeof(lnm_items)/sizeof(lnm_items[0]); ++i) {
        if (ile3_codes & (1 << lnm_items[i].item_code)) {
            item_list[ile3_idx].ile3$w_length = lnm_items[i].item_size;
            item_list[ile3_idx].ile3$w_code = lnm_items[i].item_code;
            item_list[ile3_idx].ile3$ps_bufaddr = alloca(lnm_items[i].item_size+1);
            item_list[ile3_idx].ile3$ps_retlen_addr = alloca(sizeof(short));
            switch (lnm_items[i].item_code) {
                case LNM$_INDEX:
                    // set index, if it is present. as it already goes first in lnm_items, we should not arrange it at first place
                    *(long*)item_list[ile3_idx].ile3$ps_bufaddr = lnm_index;
                    break;
                case LNM$_ATTRIBUTES:
                    if (create) {
                        // set attribute. on create only. it is before STRING
                        *(long*)item_list[ile3_idx].ile3$ps_bufaddr = lnm_attributes;
                    }
                    break;
                case LNM$_STRING:
                    if (create && lnm_string) {
                        // set string value only on create
                        item_list[ile3_idx].ile3$w_length = strlen(lnm_string);
                        *(short*)item_list[ile3_idx].ile3$ps_retlen_addr = item_list[ile3_idx].ile3$w_length;
                        strncpy(item_list[ile3_idx].ile3$ps_bufaddr, lnm_string, item_list[ile3_idx].ile3$w_length);
                    }
                    break;
            }
            ++ile3_idx;
        }
    }

#if 0
    printf("ile3_count=%i\n", ile3_count);
    printf("pattr=%p, 0x%x\n", pattr, pattr ? *pattr : 0);
    printf("tabnam=\"%.*s\"\n", tabnam_dsc.dsc$w_length, tabnam_dsc.dsc$a_pointer);
    printf("lognam=\"%.*s\"\n", lognam_dsc.dsc$w_length, lognam_dsc.dsc$a_pointer);
    for(int i = 0; i < ile3_count; ++i) {
        printf("\t item_list[%i].ile3$w_code=0x%x\n", i, item_list[i].ile3$w_code);
        printf("\t item_list[%i].ile3$w_length=%i\n", i, item_list[i].ile3$w_length);
        printf("\t *(short*)item_list[%i].ile3$ps_retlen_addr)=%i\n", i, *(short*)item_list[i].ile3$ps_retlen_addr);
        printf("\t *(unsigned long*)item_list[%i].ile3$ps_bufaddr=0x%x\n", i, *(unsigned long*)item_list[i].ile3$ps_bufaddr);
    }
#endif

    if (create) {
        status = sys$crelnm(pattr, &tabnam_dsc, plognam_dsc, pacmode, item_list);
    } else {
        status = sys$trnlnm(pattr, &tabnam_dsc, plognam_dsc, pacmode, item_list);
    }

    decc$$translate (status);

    RETVAL_FALSE;
    if (status != SS$_NORMAL) {
        return;
    }
    
    // set result
    for(int i = 0; i < ile3_count; ++i) {
        if (item_list[i].ile3$w_code == LNM$_STRING) {
            char *str = (char*)item_list[i].ile3$ps_bufaddr;
            str[*item_list[i].ile3$ps_retlen_addr] = 0;
            RETVAL_STRING(str);
            break;
        }
    }
    // fill itmlst
    if (itmlst) {
        zend_ulong idx;
        zend_string *key;
        zval *val;
        int itmlst_parsed_idx = 0;
        ZEND_HASH_FOREACH_KEY_VAL(Z_ARR_P(itmlst), idx, key, val) {
            if (key) {
                if (itmlst_parsed[itmlst_parsed_idx].code != -1) {
                    for(int i = 0; i < ile3_count; ++i) {
                        if (item_list[i].ile3$w_code == itmlst_parsed[itmlst_parsed_idx].code) {
                            if (itmlst_parsed[itmlst_parsed_idx].code == LNM$_ATTRIBUTES) {
                                if (*(unsigned long*)item_list[i].ile3$ps_bufaddr & itmlst_parsed[itmlst_parsed_idx].bitmask) {
                                    ZVAL_TRUE(val);
                                } else {
                                    ZVAL_FALSE(val);
                                }
                            } else {
                                for(int j = 0; j < sizeof(lnm_items)/sizeof(lnm_items[0]); ++j) {
                                    if (lnm_items[j].item_code == item_list[i].ile3$w_code) {
                                        FormatItemData(val, &lnm_items[j], item_list[i].ile3$ps_bufaddr, *(short*)item_list[i].ile3$ps_retlen_addr);
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                        zend_hash_add(Z_ARR_P(itmlst), key, val);
                    }
                }
                ++itmlst_parsed_idx;
            }
        } ZEND_HASH_FOREACH_END();    
    }
    return;
}

PHP_FUNCTION(openvms_trnlnm) {
    OpenVMS_LNM(execute_data, return_value, FALSE);
}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_crelnm) {
    OpenVMS_LNM(execute_data, return_value, TRUE);
}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_dellnm) {
    int         status = SS$_NORMAL;
    char*       tabnam_str = NULL;
    size_t      tabnam_len = 0;
    char*       lognam_str = NULL;
    size_t      lognam_len = 0;
    char*       acmode_str = NULL;
    size_t      acmode_len = 0;
    
    decc$$translate (status);

    ZEND_PARSE_PARAMETERS_START(1, 3)
        Z_PARAM_STRING_OR_NULL(tabnam_str, tabnam_len)
        Z_PARAM_OPTIONAL
        Z_PARAM_STRING_OR_NULL(lognam_str, lognam_len)
        Z_PARAM_STRING_OR_NULL(acmode_str, acmode_len)
    ZEND_PARSE_PARAMETERS_END();

#if 0
    printf("tabnam_str: \"%s\", %i\n", tabnam_str, tabnam_len);
    printf("lognam_str: \"%s\", %i\n", lognam_str, lognam_len);
    printf("acmode_str: \"%s\", %i\n", acmode_str, acmode_len);
#endif

    if (!tabnam_str || !tabnam_len) {
        php_error_docref (NULL TSRMLS_CC, E_WARNING, "tabnam must not be empty");
        RETURN_FALSE;
    }

    unsigned char acmode = PSL$C_USER, *pacmode = NULL;
    if (acmode_str && acmode_len) {
        int i_acmode = ParseAcmode(acmode_str);
        if (i_acmode != -1) {
            acmode = (unsigned char)i_acmode;
            pacmode = &acmode;
        }
    }

    $DESCRIPTOR(tabnam_dsc, "");
    $DESCRIPTOR(lognam_dsc, "");
    __void_ptr32 plognam_dsc = NULL;

    tabnam_dsc.dsc$w_length = tabnam_len;
    set_dsc_string(tabnam_dsc, tabnam_str);

    if (lognam_str && lognam_len) {
        lognam_dsc.dsc$w_length = lognam_len;
        set_dsc_string(lognam_dsc, lognam_str);
        plognam_dsc = &lognam_dsc;
    }

    status = sys$dellnm(&tabnam_dsc, plognam_dsc, pacmode);

    decc$$translate (status);

    if (status != SS$_NORMAL) {
        RETURN_FALSE;
    }
    RETURN_TRUE;
}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_symbol_set) {
    int         status = SS$_NORMAL;
    char*       symbol_name_str = NULL;
    size_t      symbol_name_len = 0;
    char*       symbol_value_str = NULL;
    size_t      symbol_value_len = 0;
    zend_bool   true_if_global = 0;
    
    decc$$translate (status);

    ZEND_PARSE_PARAMETERS_START(2, 3)
        Z_PARAM_STRING_OR_NULL(symbol_name_str, symbol_name_len)
        Z_PARAM_STRING_OR_NULL(symbol_value_str, symbol_value_len)
        Z_PARAM_OPTIONAL
        Z_PARAM_BOOL(true_if_global)
    ZEND_PARSE_PARAMETERS_END();

#if 0
    printf("openvms_symbol_set\n");
    printf("symbol_name_str: \"%s\", %i\n", symbol_name_str, symbol_name_len);
    printf("symbol_value_str: \"%s\", %i\n", symbol_value_str, symbol_value_len);
    printf("true_if_global: %i\n", true_if_global);
#endif

    if (!symbol_name_str || !symbol_name_len) {
        php_error_docref (NULL TSRMLS_CC, E_WARNING, "symbol_name must not be empty");
        RETURN_FALSE;
    }

    if (!symbol_value_str || !symbol_value_len) {
        php_error_docref (NULL TSRMLS_CC, E_WARNING, "symbol_value must not be empty");
        RETURN_FALSE;
    }

    $DESCRIPTOR(symbol_name_dsc, "");
    $DESCRIPTOR(symbol_value_dsc, "");

    symbol_name_dsc.dsc$w_length = symbol_name_len;
    set_dsc_string(symbol_name_dsc, symbol_name_str);

    symbol_value_dsc.dsc$w_length = symbol_value_len;
    set_dsc_string(symbol_value_dsc, symbol_value_str);

    long table_type_indicator = true_if_global ? LIB$K_CLI_GLOBAL_SYM : LIB$K_CLI_LOCAL_SYM;
    status = LIB$SET_SYMBOL(&symbol_name_dsc, &symbol_value_dsc, &table_type_indicator);

    decc$$translate (status);

    if (status != SS$_NORMAL) {
        RETURN_FALSE;
    }
    RETURN_TRUE;
}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_symbol_get) {
    int         status = SS$_NORMAL;
    char*       symbol_name_str = NULL;
    size_t      symbol_name_len = 0;
    zend_bool   true_if_global = 0;
    zend_bool   true_if_global_is_null = TRUE;
    
    decc$$translate (status);

    ZEND_PARSE_PARAMETERS_START(1, 2)
        Z_PARAM_STRING_OR_NULL(symbol_name_str, symbol_name_len)
        Z_PARAM_OPTIONAL
        Z_PARAM_BOOL_OR_NULL(true_if_global, true_if_global_is_null)
    ZEND_PARSE_PARAMETERS_END();

#if 0
    printf("openvms_symbol_get\n");
    printf("symbol_name_str: \"%s\", %i\n", symbol_name_str, symbol_name_len);
    printf("true_if_global: %i, %i\n", true_if_global, true_if_global_is_null);
#endif

    if (!symbol_name_str || !symbol_name_len) {
        php_error_docref (NULL TSRMLS_CC, E_WARNING, "symbol_name must not be empty");
        RETURN_FALSE;
    }

    $DESCRIPTOR(symbol_name_dsc, "");
    $DESCRIPTOR(symbol_value_dsc, "");

    symbol_name_dsc.dsc$w_length = symbol_name_len;
    set_dsc_string(symbol_name_dsc, symbol_name_str);

    symbol_value_dsc.dsc$w_length = 255;
    symbol_value_dsc.dsc$a_pointer = alloca(256);

    long table_type_indicator = 0;
    short result_len = 0;
    status = LIB$GET_SYMBOL(&symbol_name_dsc, &symbol_value_dsc, &result_len, &table_type_indicator);

    if (!true_if_global_is_null &&
        ((table_type_indicator == LIB$K_CLI_LOCAL_SYM && true_if_global) ||
         (table_type_indicator == LIB$K_CLI_GLOBAL_SYM && !true_if_global))) {
        status = LIB$_NOSUCHSYM;
    }

    decc$$translate (status);

    if (status != SS$_NORMAL) {
        RETURN_FALSE;
    }
    RETURN_STRINGL(symbol_value_dsc.dsc$a_pointer, result_len);
}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
PHP_FUNCTION(openvms_symbol_delete) {
    int         status = SS$_NORMAL;
    char*       symbol_name_str = NULL;
    size_t      symbol_name_len = 0;
    zend_bool   true_if_global = 0;
    
    decc$$translate (status);

    ZEND_PARSE_PARAMETERS_START(1, 2)
        Z_PARAM_STRING_OR_NULL(symbol_name_str, symbol_name_len)
        Z_PARAM_OPTIONAL
        Z_PARAM_BOOL(true_if_global)
    ZEND_PARSE_PARAMETERS_END();

#if 0
    printf("openvms_symbol_delete\n");
    printf("symbol_name_str: \"%s\", %i\n", symbol_name_str, symbol_name_len);
    printf("true_if_global: %i\n", true_if_global);
#endif

    if (!symbol_name_str || !symbol_name_len) {
        php_error_docref (NULL TSRMLS_CC, E_WARNING, "symbol_name must not be empty");
        RETURN_FALSE;
    }

    $DESCRIPTOR(symbol_name_dsc, "");

    symbol_name_dsc.dsc$w_length = symbol_name_len;
    set_dsc_string(symbol_name_dsc, symbol_name_str);

    long table_type_indicator = true_if_global ? LIB$K_CLI_GLOBAL_SYM : LIB$K_CLI_LOCAL_SYM;
    status = LIB$DELETE_SYMBOL(&symbol_name_dsc, &table_type_indicator);

    decc$$translate (status);

    if (status != SS$_NORMAL) {
        RETURN_FALSE;
    }
    RETURN_TRUE;
}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
static void FormatItemData (zval *return_value, struct item_code *ItemPtr,
		            char *ItemBuf, int ItemLen)
{

/*
** Process the booloan item codes
*/
if (ItemPtr->item_type == BOOL)
    {
    char *BoolStr = NULL;
    long BoolVal = 0;

    memcpy (&BoolVal, ItemBuf, ItemPtr->item_size);

    if (BoolVal)
	BoolStr = "TRUE";
    else
	BoolStr = "FALSE";

    RETURN_STRING (BoolStr);
    }

/*
** Process the byte item codes
*/
if (ItemPtr->item_type == BYTE)
    {
    char *BytePtr,
         *HexPtr;

    /*
    ** Process the CPUCAP_MASK array item code
    */
    if (strcasecmp (ItemPtr->item_name, "CPUCAP_MASK") == 0)
	{
        char *CpuCapMaskItm,
             *CpuCapMaskPtr;
	int CpuCapMaskCnt,
	    i;

	/*
	** Allocate a buffer knowing that CPUCAP_MASK is an array of quads
	*/
	CpuCapMaskCnt = ItemLen / 8;
	CpuCapMaskPtr = emalloc ((CpuCapMaskCnt * 8) + CpuCapMaskCnt + 1);
	strcpy (CpuCapMaskPtr, "");

	/*
	** Create the comma separated list
	*/
	for (i = 0; i < CpuCapMaskCnt; i++)
	    {
	    CpuCapMaskItm = BinToHex (&ItemBuf[i * 8], 8);
	    if (CpuCapMaskItm)
		{
		APPEND (CpuCapMaskPtr, CpuCapMaskItm, ",");
		free (CpuCapMaskItm);
		}
	    }

	/*
	** Return the CPUCAP_MASK string
	*/
        RETURN_STRING (CpuCapMaskPtr);
	}

    /*
    ** Process the CPU_AUTOSTART array item code
    */
    if (strcasecmp (ItemPtr->item_name, "CPU_AUTOSTART") == 0)
	{
        char CpuAutostartItm[3+1],
	     *CpuAutostartPtr;
	int CpuAutostartVal,
	    CpuAutostartCnt,
	    i;

	/*
	** Allocate a buffer knowing that CPU_AUTOSTART is an array of bytes
	*/
	CpuAutostartCnt = ItemLen / 1;
	CpuAutostartPtr = emalloc ((CpuAutostartCnt * sizeof (CpuAutostartItm)) + CpuAutostartCnt + 1);
	strcpy (CpuAutostartPtr, "");

	/*
	** Create the comma separated list
	*/
	for (i = 0; i < CpuAutostartCnt; i++)
	    {
	    CpuAutostartVal = *((char *) &ItemBuf[i * 1]);
	    if (CpuAutostartVal == -1)
		break;
	    sprintf (CpuAutostartItm, "%d", CpuAutostartVal);
	    APPEND (CpuAutostartPtr, CpuAutostartItm, ",");
	    }
	if (strlen (CpuAutostartPtr) == 0)
	    strcpy (CpuAutostartPtr, "0");

	/*
	** Return the CPU_AUTOSTART string
	*/
        RETURN_STRING (CpuAutostartPtr);
	}

    /*
    ** Process the CPU_FAILOVER array item code
    */
    if (strcasecmp (ItemPtr->item_name, "CPU_FAILOVER") == 0)
	{
        char CpuFailoverItm[9+1],
	     *CpuFailoverPtr;
	int CpuFailoverVal,
	    CpuFailoverCnt,
	    i;

	/*
	** Allocate a buffer knowing that CPU_FAILOVER is an array of longs
	*/
	CpuFailoverCnt = ItemLen / 4;
	CpuFailoverPtr = emalloc ((CpuFailoverCnt * sizeof (CpuFailoverItm)) + CpuFailoverCnt + 1);
	strcpy (CpuFailoverPtr, "");

	/*
	** Create the comma separated list
	*/
	for (i = 0; i < CpuFailoverCnt; i++)
	    {
	    CpuFailoverVal = *((int *) &ItemBuf[i * 4]);
	    if (CpuFailoverVal == -1)
		break;
	    sprintf (CpuFailoverItm, "%d", CpuFailoverVal);
	    APPEND (CpuFailoverPtr, CpuFailoverItm, ",");
	    }
	if (strlen (CpuFailoverPtr) == 0)
	    strcpy (CpuFailoverPtr, "0");

	/*
	** Return the CPU_FAILOVER string
	*/
        RETURN_STRING (CpuFailoverPtr);
	}

    /*
    ** Process the RAD pair item codes
    */
    if (strcasecmp (ItemPtr->item_name, "RAD_CPUS") == 0 ||
	strcasecmp (ItemPtr->item_name, "RAD_MEMSIZE") == 0 ||
	strcasecmp (ItemPtr->item_name, "RAD_SHMEMSIZE") == 0)
	{
	char RadItm[18+1],
	     *RadPtr;
	int *RadVal,
	    RadCnt,
	    i;

	/*
	** Allocate a buffer knowing that the RAD items are arrays of long pairs
	*/
	RadCnt = ItemLen / 8;
	RadPtr = emalloc ((RadCnt * sizeof (RadItm)) + RadCnt + 1);
	strcpy (RadPtr, "");

	/*
	** Create the comma separated list
	*/
	for (i = 0; i < RadCnt; i++)
	    {
	    RadVal = (int *) &ItemBuf[i * 8];
	    if (RadVal[0] == -1 && RadVal[1] == -1)
		break;
	    sprintf (RadItm, "%d,%d", RadVal[0], RadVal[1]);
	    APPEND (RadPtr, RadItm, ",");
	    }
	if (strlen (RadPtr) == 0)
	    strcpy (RadPtr, "0,0");

	/*
	** Return the RAD item string
	*/
	RETURN_STRING (RadPtr);
	}

    /*
    ** Convert the byte value to hex
    */
    HexPtr = BinToHex (ItemBuf, ItemPtr->item_size);
    if (HexPtr)
	{
	BytePtr = estrdup (HexPtr);
	free (HexPtr);
	}
    else
	BytePtr = estrdup ("");

    /*
    ** Return the byte value as a hex string
    */
    RETURN_STRING (BytePtr);
    }

/*
** Process the long item codes
*/
if (ItemPtr->item_type == LONG)
    {
    long LongVal = 0;
    int i;

    /*
    ** Copy the long value
    */
    memcpy (&LongVal, ItemBuf, ItemPtr->item_size);

    /*
    ** Process the ACPTYPE item code
    */
    if (strcasecmp (ItemPtr->item_name, "ACPTYPE") == 0)
	{
	for (i = 0; strlen (dvi_acptypes[i].item_name); i++)
	    if (LongVal == dvi_acptypes[i].item_code)
		RETURN_STRING (dvi_acptypes[i].item_name);
	RETURN_STRING ("ILLEGAL");
	}

    /*
    ** Process the MODE item code
    */
    if (strcasecmp (ItemPtr->item_name, "MODE") == 0)
	{
	for (i = 0; strlen (jpi_modes[i].item_name); i++)
	    if (LongVal == jpi_modes[i].item_code)
		RETURN_STRING (jpi_modes[i].item_name);
	RETURN_NULL ();
	}

    /*
    ** Process the Parse Style item codes
    */
    if (strcasecmp (ItemPtr->item_name, "PARSE_STYLE_IMAGE") == 0 ||
        strcasecmp (ItemPtr->item_name, "PARSE_STYLE_PERM") == 0)
	{
	for (i = 0; strlen (jpi_parse[i].item_name); i++)
	    if (LongVal == jpi_parse[i].item_code)
		RETURN_STRING (jpi_parse[i].item_name);
	RETURN_NULL ();
	}

    /*
    ** Process the STATE item code
    */
    if (strcasecmp (ItemPtr->item_name, "STATE") == 0)
	{
	for (i = 0; strlen (jpi_states[i].item_name); i++)
	    if (LongVal == jpi_states[i].item_code)
		RETURN_STRING (jpi_states[i].item_name);
	RETURN_NULL ();
	}

    /*
    ** Return the long value
    */
    RETURN_LONG (LongVal);
    }

/*
** Process the text item codes
*/
if (ItemPtr->item_type == TEXT)
    {
    /*
    ** Null terminate the text data
    */
    ItemBuf[ItemLen] = '\0';

    /*
    ** Return the text data
    */
    RETURN_STRINGL (ItemBuf, ItemLen);
    }

/*
** Process the date item codes
*/
if (ItemPtr->item_type == DATE)
    {
    char DateTimeBuf[DATE_TIME_LEN+1],
         *DateTimePtr;

    /*
    ** Convert the date/time to a string
    */
    DateTimePtr = GetDateTime ((__int64 *) ItemBuf);
    if (DateTimePtr)
	strcpy (DateTimeBuf, DateTimePtr);
    else
	strcpy (DateTimeBuf, "");

    /*
    ** Free any allocated data
    */
    if (DateTimePtr)
	free (DateTimePtr);

    /*
    ** Return the date/time string
    */
    RETURN_STRING (DateTimeBuf);
    }

/*
** Process the priv item codes
*/
if (ItemPtr->item_type == PRIV)
    {
    char PrivBuf[PRIV_BUF_LEN+1],
         *PrivPtr;

    /*
    ** Copy the privilege list to our local buffer
    */
    PrivPtr = GetPrivs ((PRVDEF *) ItemBuf);
    if (PrivPtr)
	strcpy (PrivBuf, PrivPtr);
    else
	strcpy (PrivBuf, "");

    /*
    ** Free any allocated data
    */
    if (PrivPtr)
	free (PrivPtr);

    /*
    ** Return the privilege string
    */
    RETURN_STRING (PrivBuf);
    }

/*
** Process the rights list item codes
*/
if (ItemPtr->item_type == RLST)
    {
    char *RightsBuf = NULL,
         *RightsPtr;

    /*
    ** Copy the privilege list to our local buffer
    */
    RightsPtr = GetRightsList ((unsigned int *) ItemBuf, ItemLen);
    if (RightsPtr)
	RightsBuf = estrdup (RightsPtr);
    else
	RightsBuf = estrdup ("");

    /*
    ** Free any allocated data
    */
    if (RightsPtr)
	free (RightsPtr);

    /*
    ** Return the privilege string
    */
    RETURN_STRING (RightsBuf);
    }

/*
** Process the SOGW protection item codes
*/
if (ItemPtr->item_type == SOGW)
    {
    struct dsc$descriptor OSepDesc = { 1, DSC$K_DTYPE_T, DSC$K_CLASS_S, "=" };
    struct dsc$descriptor ProtDesc = { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0 };
    char ProtBuf[PROT_BUF_LEN+1];
    int status,
	i;

    /*
    ** Set the protection descriptor
    */
    ProtDesc.dsc$w_length = PROT_BUF_LEN;
    ProtDesc.dsc$a_pointer = ProtBuf;

    /*
    ** Convert the protection mask
    */
    status = LIB$FORMAT_SOGW_PROT ((unsigned short *) ItemBuf,
				   0,
				   0,
				   &OSepDesc,
				   0,
				   &ProtDesc,
				   &ProtDesc.dsc$w_length);
    if (status & 1)
	ProtDesc.dsc$a_pointer[ProtDesc.dsc$w_length] = '\0';
    else
	{
	decc$$translate (status);
	strcpy (ProtBuf, "");
	}

    /*
    ** Upper case the protection buffer
    */
    for (i = 0; i < strlen (ProtBuf); i++)
	ProtBuf[i] = toupper (ProtBuf[i]);

    /*
    ** Return the privilege string
    */
    RETURN_STRING (ProtBuf);
    }

/*
** Process the UIC item code
*/
if (ItemPtr->item_type == UIC)
    {
    char UicName[UIC_BUF_LEN+1],
         *GrpName,
         *MemName;
    UICDEF UicVal;

    /*
    ** Copy the Uic
    */
    memcpy (&UicVal, ItemBuf, sizeof (UicVal));

    /*
    ** Get the UIC member name
    */
    MemName = GetIdent (UicVal.uic$l_uic);

    /*
    ** Now, let's get the member wild so we can get the group
    */
    UicVal.uic$w_mem = UIC$K_WILD_MEMBER;

    /*
    ** Get the UIC group name
    */
    GrpName = GetIdent (UicVal.uic$l_uic);

    /*
    ** Format the UIC string
    */
    if (GrpName && MemName)
        sprintf (UicName, "[%s,%s]", GrpName, MemName);
    else
        if (MemName)
	    sprintf (UicName, "[%s]", MemName);
        else
	    {
	    memcpy (&UicVal, ItemBuf, sizeof (UicVal));
	    sprintf (UicName, "[%o,%o]", UicVal.uic$w_grp, UicVal.uic$w_mem);
	    }

    /*
    ** Free any allocated data
    */
    if (GrpName)
        free (GrpName);
    if (MemName)
        free (MemName);

    /*
    ** Return the system right
    */
    RETURN_STRING (UicName);
    }

RETURN_FALSE;

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
static int GetRightsSize (char *ItemName,
			  struct dsc$descriptor *JpiProcDescPtr,
			  unsigned int JpiPidVal)
{
int RlstSizeCode = JPI$_RIGHTS_SIZE;
int RlstSizeLen = 0;
char *RlstSizeName;
ILE3 JpiItems[2];
ILE3 *Ile3Ptr;
IOSB iosb;
int status,
    i;


/*
** Check to see if the list provided list has a specific rights
*/
RlstSizeName = malloc (strlen (ItemName) + 5 + 1);
if (RlstSizeName)
    {
    sprintf (RlstSizeName, "%s_SIZE", ItemName);
    for (i = 0; strlen (jpi_items[i].item_name); i++)
	{
	if (strcasecmp (jpi_items[i].item_name, RlstSizeName) == 0)
	    {
	    RlstSizeCode = jpi_items[i].item_code;
	    break;
	    }
	}
    free (RlstSizeName);
    }

/*
** Setup the JPI item list
*/
ILE3_INIT (JpiItems);
ILE3_ADD  (RlstSizeCode, sizeof (RlstSizeLen), &RlstSizeLen, 0);
ILE3_TERM;

/*
** Get the JPI information
*/
status = SYS$GETJPIW (EFN$C_ENF,		/* No event flag              */
                      &JpiPidVal, 		/* PID address                */
                      JpiProcDescPtr,		/* Process name descriptor    */
                      &JpiItems,		/* Item list                  */
                      &iosb,			/* IOSB                       */
                      0,			/* No AST routine             */
                      0);			/* No AST parameter           */
if (status & 1)
    status = iosb.iosb$w_status;
if (! (status & 1))
    {
    decc$$translate (status);
    RlstSizeLen = 8;
    }

return (RlstSizeLen);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
static char *GetRightsList (unsigned int *IdentBuf, int IdentLen)
{
char *RlstBuf = NULL,
     *IdentName;
int RlstLen = 0,
    i;


/*
** Parse the rights list identifiers into a list
*/
for (i = 0; (i * 4) < IdentLen; i = i + 2)
    {
    IdentName = GetIdent (IdentBuf[i]);
    if (IdentName)
	{
	if (RlstBuf == NULL)
	    {
	    RlstLen = MAX (strlen (IdentName), 256);
	    RlstBuf = malloc (RlstLen + 1);
	    strcpy (RlstBuf, IdentName);
	    }
	else
	    {
	    if (strlen (RlstBuf) + strlen (IdentName) + 1 > RlstLen)
		{
		RlstLen = RlstLen + MAX (strlen (IdentName) + 1, 256);
		RlstBuf = realloc (RlstBuf, RlstLen + 1);
		}
	    strcat (RlstBuf, ",");
	    strcat (RlstBuf, IdentName);
	    }
	free (IdentName);
	}
    }

/*
** Return the rights list buffer
*/
return (RlstBuf);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
static char *BinToHex (char *BinBuf, int BinLen)
{
int HexLen = BinLen * 2;
char *HexBuf,
     *HexPtr,
      HexChr[2+1];
int i;

/*
** Size the return hex buffer
*/
HexBuf = malloc (HexLen + 1);
memset (HexBuf, 0, HexLen + 1);
HexPtr = (HexBuf + HexLen) - 2;

/*
** Convert the binary value to hex
*/
for (i = 0; i < BinLen; i++)
    {
    sprintf (HexChr, "%02X", (unsigned char) BinBuf[i]);
    strncpy (HexPtr, HexChr, 2);
    HexPtr = (char *) ((unsigned int) HexPtr - 2);
    }

return (HexBuf);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
static char *GetDateTime (__int64 *DateTimePtr)
{
struct dsc$descriptor DateTimeDesc = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0};
char DateTimeBuf[DATE_TIME_LEN + 1];
int status;


/*
** Setup the Ascii time descriptor
*/
DateTimeDesc.dsc$w_length = DATE_TIME_LEN;
DateTimeDesc.dsc$a_pointer = DateTimeBuf;

/*
** Get the Ascii time
*/
status = SYS$ASCTIM (&DateTimeDesc.dsc$w_length,
		     &DateTimeDesc,
		     (void *) DateTimePtr,
		     0);
if (status & 1)
    DateTimeDesc.dsc$a_pointer[DateTimeDesc.dsc$w_length] = '\0';
else
    {
    DateTimeDesc.dsc$a_pointer[0] = '\0';
    decc$$translate (status);
    }

/*
** Return the converted identifier
*/
if (strlen (DateTimeBuf))
    return (strdup (DateTimeBuf));
else
    return (NULL);
}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
static char *GetPrivs (PRVDEF *PrivMask)
{
char PrivBuf[PRIV_BUF_LEN+1];


/*
** Clear the privilege buffer
*/
memset (PrivBuf, 0, sizeof (PrivBuf));

/*
** Translate the privilege mask into the privilege buffer
*/
if (PrivMask->prv$v_cmkrnl)		APPEND (PrivBuf, "CMKRNL", ",");
if (PrivMask->prv$v_cmexec)		APPEND (PrivBuf, "CMEXEC", ",");
if (PrivMask->prv$v_sysnam)		APPEND (PrivBuf, "SYSNAM", ",");
if (PrivMask->prv$v_grpnam)		APPEND (PrivBuf, "GRPNAM", ",");
if (PrivMask->prv$v_allspool)		APPEND (PrivBuf, "ALLSPOOL", ",");
if (PrivMask->prv$v_detach)		APPEND (PrivBuf, "DETACH", ",");
if (PrivMask->prv$v_diagnose)		APPEND (PrivBuf, "DIAGNOSE", ",");
if (PrivMask->prv$v_log_io)		APPEND (PrivBuf, "LOG_IO", ",");
if (PrivMask->prv$v_group)		APPEND (PrivBuf, "GROUP", ",");
if (PrivMask->prv$v_noacnt)		APPEND (PrivBuf, "NOACNT", ",");
if (PrivMask->prv$v_prmceb)		APPEND (PrivBuf, "PRMCEB", ",");
if (PrivMask->prv$v_prmmbx)		APPEND (PrivBuf, "PRMMBX", ",");
if (PrivMask->prv$v_pswapm)		APPEND (PrivBuf, "PSWAPM", ",");
if (PrivMask->prv$v_altpri)		APPEND (PrivBuf, "ALTPRI", ",");
if (PrivMask->prv$v_setprv)		APPEND (PrivBuf, "SETPRV", ",");
if (PrivMask->prv$v_tmpmbx)		APPEND (PrivBuf, "TMPMBX", ",");
if (PrivMask->prv$v_world)		APPEND (PrivBuf, "WORLD", ",");
if (PrivMask->prv$v_mount)		APPEND (PrivBuf, "MOUNT", ",");
if (PrivMask->prv$v_oper)		APPEND (PrivBuf, "OPER", ",");
if (PrivMask->prv$v_exquota)		APPEND (PrivBuf, "EXQUOTA", ",");
if (PrivMask->prv$v_netmbx)		APPEND (PrivBuf, "NETMBX", ",");
if (PrivMask->prv$v_volpro)		APPEND (PrivBuf, "VOLPRO", ",");
if (PrivMask->prv$v_phy_io)		APPEND (PrivBuf, "PHY_IO", ",");
if (PrivMask->prv$v_bugchk)		APPEND (PrivBuf, "BUGCHK", ",");
if (PrivMask->prv$v_prmgbl)		APPEND (PrivBuf, "PRMGBL", ",");
if (PrivMask->prv$v_sysgbl)		APPEND (PrivBuf, "SYSGBL", ",");
if (PrivMask->prv$v_pfnmap)		APPEND (PrivBuf, "PFNMAP", ",");
if (PrivMask->prv$v_shmem)		APPEND (PrivBuf, "SHMEM", ",");
if (PrivMask->prv$v_sysprv)		APPEND (PrivBuf, "SYSPRV", ",");
if (PrivMask->prv$v_bypass)		APPEND (PrivBuf, "BYPASS", ",");
if (PrivMask->prv$v_syslck)		APPEND (PrivBuf, "SYSLCK", ",");
if (PrivMask->prv$v_share)		APPEND (PrivBuf, "SHARE", ",");
if (PrivMask->prv$v_upgrade)		APPEND (PrivBuf, "UPGRADE", ",");
if (PrivMask->prv$v_downgrade)		APPEND (PrivBuf, "DOWNGRADE", ",");
if (PrivMask->prv$v_grpprv)		APPEND (PrivBuf, "GRPPRV", ",");
if (PrivMask->prv$v_readall)		APPEND (PrivBuf, "READALL", ",");
if (PrivMask->prv$v_import)		APPEND (PrivBuf, "IMPORT", ",");
if (PrivMask->prv$v_audit)		APPEND (PrivBuf, "AUDIT", ",");
if (PrivMask->prv$v_security)		APPEND (PrivBuf, "SECURITY", ",");

/*
** Return the privilege list
*/
if (strlen (PrivBuf))
    return (strdup (PrivBuf));
else
    return (NULL);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
static char *GetIdent (unsigned int Ident)
{
struct dsc$descriptor IdentDesc = { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0 };
char IdentBuf[IDENT_BUF_LEN+1];
int status, i;


/*
** Load the identifier descriptor
*/
IdentDesc.dsc$w_length = IDENT_BUF_LEN;
IdentDesc.dsc$a_pointer = IdentBuf;

/*
** Convert the identifier value to ascii
*/
status = SYS$IDTOASC (Ident,
		      &IdentDesc.dsc$w_length,
		      &IdentDesc,
		      0,
		      0,
		      0);
if (status & 1)
    for (i = IdentDesc.dsc$w_length; i >= 0 && IdentDesc.dsc$a_pointer[i] == ' '; i--);
else
    {
    decc$$translate (status);
    i = -1;
    }
IdentDesc.dsc$a_pointer[i+1] = '\0';

/*
** Return the converted identifier
*/
if (strlen (IdentDesc.dsc$a_pointer))
    return (strdup (IdentDesc.dsc$a_pointer));
else
    return (NULL);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
static int GetMaxCpus (struct dsc$descriptor *SyiNodeDescPtr,
		       unsigned int SyiCsidVal)
{
ILE3 SyiItems[2];
int MaxCpus = 0;
ILE3 *Ile3Ptr;
int status;
IOSB iosb;


/*
** Setup the SYI item list
*/
ILE3_INIT (SyiItems);
ILE3_ADD  (SYI$_MAX_CPUS, sizeof (MaxCpus), &MaxCpus, 0);
ILE3_TERM;

/*
** Get the SYI information
*/
status = SYS$GETSYIW (EFN$C_ENF,		/* No event flag              */
                      &SyiCsidVal, 		/* CSID address               */
                      SyiNodeDescPtr,		/* Node name descriptor       */
                      &SyiItems,		/* Item list                  */
                      &iosb,			/* IOSB                       */
                      0,			/* No AST routine             */
                      0);			/* No AST parameter           */
if (status & 1)
    status = iosb.iosb$w_status;
if (! (status & 1))
    {
    decc$$translate (status);
    MaxCpus = 1;
    }

return (MaxCpus);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/
static int GetMaxRads (struct dsc$descriptor *SyiNodeDescPtr,
		       unsigned int SyiCsidVal)
{
ILE3 SyiItems[2];
int MaxRads = 0;
ILE3 *Ile3Ptr;
int status;
IOSB iosb;


/*
** Setup the SYI item list
*/
ILE3_INIT (SyiItems);
ILE3_ADD  (SYI$_RAD_MAX_RADS, sizeof (MaxRads), &MaxRads, 0);
ILE3_TERM;

/*
** Get the SYI information
*/
status = SYS$GETSYIW (EFN$C_ENF,		/* No event flag              */
                      &SyiCsidVal, 		/* CSID address               */
                      SyiNodeDescPtr,		/* Node name descriptor       */
                      &SyiItems,		/* Item list                  */
                      &iosb,			/* IOSB                       */
                      0,			/* No AST routine             */
                      0);			/* No AST parameter           */
if (status & 1)
    status = iosb.iosb$w_status;
if (! (status & 1))
    {
    decc$$translate (status);
    MaxRads = 1;
    }

return (MaxRads);

}

/******************************************************************************/
/***                                                                        ***/
/******************************************************************************/

static const char *acmodes[] = {
    "KERNEL",   // 0
    "EXEC",     // 1
    "SUPER",    // 2
    "USER",     // 3
};

/**
 * Parses acmode_str
 * @return acmode [0-3] or -1
*/
static int ParseAcmode(const char* acmode_str) {
    const char *end = acmode_str;
    int i_acmode = FindToken(end, &end, "", acmodes, sizeof(acmodes)/sizeof(char*), sizeof(char*));
#if 0
    printf("i_acmode=%i\n", i_acmode);
#endif
    if (i_acmode != -1) {
        return i_acmode;
    }
    // allow modes 1-3 ?
    i_acmode = atoi(acmode_str);
    if (0 < i_acmode && i_acmode < 4 ) {
        return i_acmode;
    }
    return -1;
}
static int is_delim(char source, const char* delim) {
    if (!source) { 
        return TRUE;
    }
    while(*delim && source != *delim) {
        ++delim;
    }
    return (0 != *delim);
}

static int is_like(const char *source, const char *test) {
    while(*source && *test && tolower((unsigned char)*source) == tolower((unsigned char)*test)) {
        ++source;
        ++test;
    }
    return 0 == *test;
}

static int FindToken(const char *source, const char **end, const char *delim, const char** tokens, int length, int stride) {
    // skip delimiters
    while(*source && is_delim(*source, delim)) {
        ++source;
    }
    if (!*source) {
        if (end) {
            *end = source;
        }
        return -2;
    } else {
        // find 
        for(int i = 0; i < length; ++i) {
            if (is_like(source, *tokens)) {
                if (end) {
                    *end = source + strlen(*tokens);
                }
                return i;
            }
            tokens = (const char**)(((char*)tokens) + stride);
        }
        if (end) {
            // skip this token
            while(*source && !is_delim(*source, delim)) {
                ++source;
            }
            *end = source;
        }
        return -1;
    }
}

/**
 * Parse bits_str and fill result
 * @param result combination of bits from codes[idx].item_code, if codes[idx].item_name is present in bits_str
 * @result FALSE if some in bits_str is not present in codes
*/
static int ParseBits(unsigned long *result, const char *bits_str, struct item_code *codes, int codes_len) {
    if (!result) {
        return FALSE;
    }
    *result = 0;
    const char *end = bits_str;
    while(*end) {
        int idx = FindToken(end, &end, " ,|", (const char**)codes, codes_len, sizeof(struct item_code));
        if (idx >= 0) {
            *result |= codes[idx].item_code;
        } else if (idx == -1) {
            // invlid name?
            return FALSE;
        }
    }
    return TRUE;
}
